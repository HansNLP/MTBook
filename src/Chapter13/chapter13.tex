% !Mode:: "TeX:UTF-8"
% !TEX encoding = UTF-8 Unicode

%----------------------------------------------------------------------------------------
% 机器翻译：基础与模型
% Machine Translation: Foundations and Models
%
% Copyright 2020
% 肖桐(xiaotong@mail.neu.edu.cn) 朱靖波 (zhujingbo@mail.neu.edu.cn)
%----------------------------------------------------------------------------------------

%----------------------------------------------------------------------------------------
%    CONFIGURATIONS
%----------------------------------------------------------------------------------------
\part{机器翻译前沿}
\renewcommand\figurename{图}%将figure改为图
\renewcommand\tablename{表}%将figure改为图
\chapterimage{fig-NEU-4.jpg} % Chapter heading image

%----------------------------------------------------------------------------------------
%	CHAPTER 13
%----------------------------------------------------------------------------------------

\chapter{神经机器翻译模型训练}

\parinterval 模型训练是机器翻译领域的重要研究方向，其中的很多发现对其它自然语言处理任务也有很好的借鉴意义。特别是，训练神经机器翻译仍然面临一些挑战，包括：

\begin{itemize}
\vspace{0.5em}
\item 如何对大容量模型进行有效的训练？例如，避免过拟合问题，并让模型更加健壮，同时有效地处理更大的词汇表。
\vspace{0.5em}
\item 如何设计更好的模型训练策略？例如，在训练中更好地利用机器翻译评价指标，同时选择对翻译更有价值的样本进行模型训练。
\vspace{0.5em}
\item 如何让模型学习到的“知识”在模型之间迁移？例如，把一个“强”模型的能力迁移到一个“弱”模型上，而这种能力可能是无法通过直接训练“弱”模型得到的。
\vspace{0.5em}
\end{itemize}

\parinterval 本章将就这些问题展开讨论，内容会覆盖开放词表、正则化、对抗样本训练、最小风险训练、知识蒸馏等多个主题。需要注意的是，神经机器翻译模型训练涉及的内容十分广泛。很多情况下，模型训练问题会和建模问题强相关。因此，本章的内容主要集中在相对独立的基础模型训练问题上。在后续章节中，仍然会有模型训练方面的介绍，其主要针对机器翻译的特定主题，如深层神经网络训练、无指导训练等。

%----------------------------------------------------------------------------------------
%    NEW SECTION
%----------------------------------------------------------------------------------------

\sectionnewpage
\section{开放词表}

\parinterval 对于神经机器翻译而言，研究人员通常希望使用更大的词表完成模型训练。因为大词表可以覆盖更多的语言现象，使模型对不同的语言现象有更强的区分能力。但是，人类的语言表达方式是十分多样的，这也体现在单词的构成上，甚至人们都无法想象数据中存在的不同单词的数量。比如，在WMT、CCMT等评测数据上，英语词表大小都会在100万以上。如果不加限制，机器翻译的词表将会很“大”。这也会导致模型参数量变大，模型训练变得极为困难。更严重的问题是，测试数据中的一些单词根本就没有在训练数据中出现过，这时会出现未登录词翻译问题（即OOV问题），即系统无法对未见单词进行翻译。在神经机器翻译中，通常会考虑使用更小的翻译单元来缓解数据稀疏问题。

%----------------------------------------------------------------------------------------
%    NEW SUB-SECTION
%----------------------------------------------------------------------------------------

\subsection{大词表和未登录词问题}

\parinterval 首先来具体看一看神经机器翻译的大词表问题。神经机器翻译模型训练和推断都依赖于源语言和目标语言的词表（见{\chapterten}）。在建模中，词表中的每一个单词都会被转换为分布式（向量）表示，即词嵌入。如果每个单词都对应一个向量，那么单词的各种变形（时态、语态等）都会导致词表增大，同时增加词嵌入表示的难度。如果要覆盖更多的翻译现象，词表会不断膨胀，并带来两个问题：

\begin{itemize}
\vspace{0.5em}
\item {\small\bfnew{数据稀疏}}。很多不常见的低频词包含在词表中，而这些低频词的词嵌入表示很难得到充分学习。
\vspace{0.5em}
\item {\small\bfnew{参数及计算量的增大}}。大词表会增加词嵌入矩阵的大小，同时也会显著增加输出层中线性变换和Softmax的计算量。
\vspace{0.5em}
\end{itemize}

\parinterval 理想情况下，机器翻译应该是一个{\small\bfnew{开放词表}}\index{开放词表}（Open Vocabulary）\index{Open Vocabulary}的翻译任务。也就是，无论测试数据中包含什么样的词，机器翻译系统都应该能够正常翻译。但是，现实的情况是即使不断扩充词表，也不可能覆盖所有可能的单词。这个问题在使用受限词表时会更加严重，因为低频词和未见过的词都会被看作未登录词。这时会将这些单词用符号<UNK>代替。通常，数据中<UNK>的数量会直接影响翻译性能，过多的<UNK>会造成欠翻译、结构混乱等问题。因此神经机器翻译需要额外的机制解决大词表和未登录词问题。

%----------------------------------------------------------------------------------------
%    NEW SUB-SECTION
%----------------------------------------------------------------------------------------

\subsection{子词}

\parinterval 一种解决开放词表翻译问题的思路是改造输出层结构\upcite{garcia-martinez2016factored,DBLP:conf/acl/JeanCMB15}，比如，替换原始的Softmax层，用更加高效的神经网络结构进行超大规模词表上的预测。不过，模型结构和训练方法的调整使得系统开发与调试的工作量增加，并且这类方法仍然无法解决未登录词问题，因此在实用系统中并不常用。

\parinterval 另一种思路是不改变机器翻译系统，而是从数据处理的角度来缓解未登录词问题。既然使用单词会带来数据稀疏问题，那么自然会想到使用更小的单元，通过更小的单元的多种排列组合来表示更多的单词。比如，把字符作为最小的翻译单元 \footnote{汉语里的字符可以被看作是汉字。} \ \dash \ 也就是基于字符的翻译模型\upcite{DBLP:journals/tacl/LeeCH17}。以英语为例，只需要构造一个包含26个英语字母、数字和一些特殊符号的字符表，便可以表示所有的单词。

\parinterval 但是字符级翻译也面临着新的问题\ \dash\ 使用字符增加了系统捕捉不同语言单元之间搭配的难度。假设平均一个单词由5个字符组成，系统所处理的序列长度便增大5倍。这使得具有独立意义的不同语言单元需要跨越更远的距离才能产生联系。此外，基于字符的方法也破坏了单词中天然存在的构词规律，或者说破坏了单词内字符的局部依赖。比如，英语单词“telephone”中的“tele”和“phone”都是有具体意义的词缀，但是如果把它们打散为字符就失去了这些含义。

\parinterval 那么有没有一种方式能够兼顾基于单词和基于字符方法的优点呢？常用的手段包括两种，一种是采用字词融合的方式构建词表，将未知单词转换为字符的序列并通过特殊的标记将其与普通的单词区分开来\upcite{luong2016acl_hybrid}。而另一种方式是将单词切分为{\small\bfnew{子词}}\index{子词}（Sub-word）\index{Sub-word}，它是介于单词和字符中间的一种语言单元表示形式。比如，将英语单词“doing”切分为“do”+“ing”。对于形态学丰富的语言来说，子词体现了一种具有独立意义的构词基本单元。如图\ref{fig:13-1}，子词“do”和“new”可以用于组成其他不同形态的单词。

%----------------------------------------------
\begin{figure}[htp]
\centering
\input{./Chapter13/Figures/figure-word-root}
\caption{不同单词共享相同的子词（前缀）}
\label{fig:13-1}
\end{figure}
%----------------------------------------------

\parinterval 在一些极端的情况下，子词仍然可以包含所有的字母和数字。这样，理论上，所有的单词都可以用子词进行组装。当然，理想的状况是：在子词词表不太大的前提下，使用尽可能少的子词单元拼装出每个单词。在神经机器翻译中，基于子词的切分是很常用的数据处理方法，称为子词切分。主要包括三个步骤：

\begin{itemize}
\vspace{0.5em}
\item 对原始数据进行分词操作；
\vspace{0.5em}
\item 构建符号合并表；
\vspace{0.5em}
\item 根据合并表，将字符合并为子词。
\vspace{0.5em}
\end{itemize}

\parinterval 这里面的核心是如何构建符号合并表，下面对一些常用方法进行介绍。

%----------------------------------------------------------------------------------------
%    NEW SUB-SECTION
%----------------------------------------------------------------------------------------

\subsection{双字节编码}

\parinterval 字节对编码或双字节编码（BPE）是一种常用的子词词表构建方法。BPE方法最早用于数据压缩，该方法将数据中常见的连续字符串替换为一个不存在的字符，之后通过构建一个替换关系的对应表，对压缩后的数据进行还原\upcite{Gage1994ANA}。机器翻译借用了这种思想，把子词切分看作是学习对自然语言句子进行压缩编码表示的问题\upcite{DBLP:conf/acl/SennrichHB16a}。其目的是，保证编码（即子词切分）后的结果占用的字节尽可能少。这样，子词单元会尽可能被不同单词复用，同时又不会因为使用过小的单元造成子词切分后的序列过长。

\parinterval 使用BPE算法进行子词切分包含两个步骤。首先，通过统计的方法构造符号合并表（见图\ref{fig:13-2}），具体的方式为：先对分过词的文本进行统计，得到词表和词频，同时将词表中的单词分割为字符表示；其次统计词表中所有出现的二元组的频次，选择当前频次最高的二元组加入符号合并表，并将所有词表中出现的该二元组合并为一个单元；不断地重复上述过程，直到合并表的大小达到预先设定的大小，或者无法继续合并。图\ref{fig:13-3}给出了一个使用字符合并表对单词进行子词切分的实例。红色单元为每次合并后得到的新符号，直至无法合并，或遍历结束，得到最终的合并结果。其中每一个单元为一个子词。

%----------------------------------------------
\begin{figure}[htp]
\centering
\input{./Chapter13/Figures/figure-bpe}
\caption{BPE算法中符号合并表的生成过程}
\label{fig:13-2}
\end{figure}
%----------------------------------------------

%----------------------------------------------
\begin{figure}[htp]
\centering
\input{./Chapter13/Figures/figure-unk-of-bpe}
\caption{BPE中的子词切分过程}
\label{fig:13-3}
\end{figure}
%----------------------------------------------

\parinterval 使用BPE方法后，翻译模型的输出也是子词序列，因此需要对最终得到的翻译结果进行子词还原，即将子词形式表达的单元重新组合为原本的单词。这一步操作也十分简单，只需要不断的将每个子词向后合并，直至遇到表示单词边界的终结符，便得到了一个完整的单词。

\parinterval 使用BPE方法的策略有很多。不仅可以单独对源语言和目标语言句子进行子词的切分，也可以联合两种语言，共同进行子词切分，被称作{\small\bfnew{双字节联合编码}}\index{双字节联合编码}（Joint-BPE\index{Joint-BPE}）\upcite{DBLP:conf/acl/SennrichHB16a}。 相比于单语BPE，Joint-BPE可以增加两种语言子词切分的一致性。对于相似语系中的语言，如英语和德语，常使用Joint-BPE 的方法联合构建词表。而对于汉语和英语这些差异比较大的语种，则需要独立地进行子词切分。

\parinterval BPE还有很多变种方法。比如，可以设计更合理的符号合并优先级。这种方法的出发点在于，在不考虑优先级的情况下，在对一个单词用同一个合并表切分子词时，可能存在多种结果。如hello，可以被切分为“hell”和“o”，也可以被切分为“h” 和“ello”。 这种切分方式的多样性可以用来提高神经机器翻译系统的健壮性\upcite{DBLP:conf/acl/Kudo18}。此外，尽管BPE也被命名为双字节编码，但是在实践中该方法一般处理的是Unicode编码，而不是字节。相应的，在预训练模型GPT2 中也探索了字节级别的BPE，这种方法在机器翻译、自动问答等任务中取得了很好的效果\upcite{radford2019language}。

%----------------------------------------------------------------------------------------
%    NEW SUB-SECTION
%----------------------------------------------------------------------------------------

\subsection{其他方法}

\parinterval 与基于统计的BPE算法不同，基于Word Piece的子词切分方法利用语言模型进行子词词表的构造\upcite{DBLP:conf/icassp/SchusterN12}。本质上，基于语言模型的方法和基于BPE的方法的思路相同，即通过合并字符和子词不断生成新的子词。它们的区别在于合并子词的方式，基于BPE的方法选择出现频次最高的连续字符进行合并，而基于语言模型的方法则是根据语言模型输出的概率选择要合并哪些子词。具体来说，基于Word Piece的方法首先将句子切割为字符表示的形式\upcite{DBLP:conf/icassp/SchusterN12}，并利用该数据训练一个1-gram语言模型，记为$\textrm{log}\funp{P}(\cdot)$。假设两个相邻的子词单元$a$和$b$被合并为新的子词$c$，则整个句子的语言模型得分的变化为$\triangle=\textrm{log}\funp{P}(c)-\textrm{log}\funp{P}(a)-\textrm{log}\funp{P}(b)$。这样，可以不断的选择使$\triangle$最大的两个子词单元进行合并，直到达到预设的词表大小或者句子概率的增量低于某个阈值。

\parinterval 目前比较主流的子词切分方法都是作用于分词后的序列，对一些没有明显词边界且资源稀缺的语种并不友好。相比之下，Sentence Piece方法可以作用于未经过分词处理的输入序列\upcite{kudo2018sentencepiece}，同时囊括了双字节编码和语言模型的子词切分方法，更加灵活易用。

\parinterval 不过在以BPE为代表的子词切分方法中，每个单词都对应一种唯一的子词切分方式，因此输入的数据经过子词切分后的序列表示也是唯一的。一旦切分出现错误，整句话的翻译效果可能会变得很差。为此，研究人员提出一些规范化方法\upcite{DBLP:conf/acl/Kudo18,provilkov2020bpe}。

\begin{itemize}
\vspace{0.5em}
\item {\small\bfnew{子词规范化方法}}\upcite{DBLP:conf/acl/Kudo18}。其做法是根据1-gram语言模型采样出多种子词切分候选。之后，最大化整个句子的概率为目标来构建词表。
\vspace{0.5em}
\item {\small\bfnew{BPE-Dropout}}\upcite{provilkov2020bpe}。在训练时，按照一定概率$p$随机丢弃一些可行的合并操作，从而产生不同的子词切分结果。而在推断阶段，将$p$设置为0，等同于标准的BPE。总的来说，上述方法相当于在子词的粒度上对输入的序列进行扰动，进而达到增加训练健壮性的目的。
\vspace{0.5em}
\item {\small\bfnew{动态规划编码}}\index{动态规划编码}（Dynamic Programming Encoding，DPE\index{Dynamic Programming Encoding，DPE}）\upcite{he2020dynamic}。引入了混合字符-子词的切分方式，将句子的子词切分看作一种隐含变量。机器翻译解码端的输入是基于字符表示的目标语言序列，推断时将每个时间步的输出映射到预先设定好的子词词表之上，得到当前最可能的子词结果。
\vspace{0.5em}
\end{itemize}

%----------------------------------------------------------------------------------------
%    NEW SECTION
%----------------------------------------------------------------------------------------

\sectionnewpage
\section{正则化}\label{subsection-13.2}

\parinterval 正则化是机器学习中的经典技术，通常用于缓解过拟合问题。正则化的概念源自线性代数和代数几何。在实践中，它更多的是指对{\small\bfnew{反问题}}\index{反问题}（The Inverse Problem）\index{Inverse Problem}的一种求解方式。假设输入$x$和输出$y$之间存在一种映射$f$：
\begin{eqnarray}
y &=& f(x)
\label{eq:13-1}
\end{eqnarray}

\noindent 反问题是指：当观测到$y$时，能否求出$x$。反问题对应了很多实际问题，比如，可以把$y$看作经过美化的图片，$x$看作原始的图片，反问题就对应了图片还原。机器翻译的训练也是一种反问题，因为可以把$y$看作是正确的译文，$x$看作是输入句子或者模型参数\footnote{在训练中，如果把源语言句子看作是不变的量，这时函数$f(\cdot)$的输入只有模型参数。}。

\parinterval 理想的情况下，研究人员希望反问题的解是{\small\bfnew{适定的}}\index{适定的}（Well-posed）\index{Well-posed}。所谓适定解，需要满足三个条件：解是存在的、解是唯一的、解是稳定的（即$y$微小的变化会导致$x$微小的变化，也被称作解连续）。所有不存在唯一稳定解的问题都被称作{\small\bfnew{不适定问题}}\index{不适定问题}（Ill-posed Problem）\index{Ill-posed Problem}。对于机器学习问题，解的存在性比较容易理解。解的唯一性大多由问题决定。比如，如果把描述问题的函数$f(\cdot)$看作一个$n\times n$矩阵$\mathbi{A}$，$x$和$y$都看作是$n$维向量。那么$x$不唯一的原因在于$\mathbi{A}$不满秩（非奇异矩阵）。不过，存在性和唯一性并不会对机器学习方法造成太大困扰，因为在实践中往往会找到近似的解。但是，解的稳定性却给神经机器翻译带来了很大的挑战。因为神经机器翻译模型非常复杂，里面存在大量的矩阵乘法和非线性变换。这导致$f(\cdot)$往往是不稳定的，也就是说，神经机器翻译中输出$y$的微小变化会导致输入$x$的巨大变化。比如，在系统研发中经常会发现，即使训练样本发生很小的变化，模型训练得到的参数都会有非常明显的区别。不仅如此，在神经机器翻译模型中，稳定性训练还面临两方面问题：

\begin{itemize}
\vspace{0.5em}
\item {\small\bfnew{观测数据不充分}}。由于语言表达的多样性，训练样本只能覆盖非常有限的翻译现象。从样本的表示空间上看，对于没有观测样本的区域，根本无法知道真实解的样子，因此也很难描述这些样本的性质，更不用说稳定性训练了。
\vspace{0.5em}
\item {\small\bfnew{数据中存在噪声}}。噪声问题是稳定性训练最大的挑战之一。因为，即使是很小的噪声，也可能会导致解的巨大变化。
\vspace{0.5em}
\end{itemize}

\parinterval 以上问题体现出来的现象就是过拟合。因为训练数据有限且存在噪声，因此模型参数会过分拟合噪声数据。而且，这样的模型参数又与真实（理想）的模型参数相差很远。正则化正是针对这个问题。有时候，正则化也被称作{\small\bfnew{降噪}}\index{降噪}（Denoising）\index{Denoising}，虽然它的出发点并不只是去除噪声的影响。图\ref{fig:13-4}对比了不同函数对二维空间中一些数据点的拟合情况。在过拟合现象中，函数可以完美的拟合所有的数据点，即使有些数据点是噪声。

%----------------------------------------------
\begin{figure}[htp]
\centering
\input{./Chapter13/Figures/figure-underfitting-vs-overfitting}
\caption{欠拟合 vs 过拟合}
\label{fig:13-4}
\end{figure}
%----------------------------------------------

\parinterval 正则化的一种实现是在训练目标中引入一个正则项。在神经机器翻译中，引入正则项的训练目标为：
\begin{eqnarray}
\widehat{\mathbi{w}} &=& \argmin_{\mathbi{w}}\textrm{Loss}(\mathbi{w}) + \lambda R(\mathbi{w})
\label{eq:13-2}
\end{eqnarray}

\noindent 其中，$\mathbi{w}$是模型参数，$\textrm{Loss}(\mathbi{w})$是损失函数，$R(\mathbi{w})$是正则项，$\lambda$是正则项的系数，用于控制正则化对训练影响的程度。$R(\mathbi{w})$通常也可以被看作是一种先验，因为在数据不充分且存在噪声的情况下，可以根据一些先验知识让模型偏向正确的方向一些，而不是一味地根据受噪声影响的$\textrm{Loss}(\mathbi{w})$进行优化。相应的，引入正则化后的模型可以获得更好的{\small\bfnew{泛化}}\index{泛化}（Generalization）\index{Generalization}能力，即模型在新的未见数据上表现会更好。

\parinterval 实践中已经证明，正则化方法有助于使得像神经机器翻译模型这样复杂模型获得稳定的模型参数。甚至有些情况下，如果不引入正则化，训练得到的翻译模型根本无法使用。此外，正则化方法不仅可以用于提高模型的泛化能力，也可以作为干预模型学习的一种手段，比如，可以将一些先验知识作为正则项约束机器翻译模型的学习。类似的手段在本书后续的内容中也会被使用。

%----------------------------------------------------------------------------------------
%    NEW SUB-SECTION
%----------------------------------------------------------------------------------------

\subsection{L1/L2正则化}

\parinterval L1/L2正则化是常用的正则化方法，虽然这种方法并不仅针对机器翻译模型。L1/L2正则化分别对应正则项是$l_1$和$l_2$范数的情况。具体来说，L1正则化是指：
\begin{eqnarray}
R(\mathbi{w}) & = & {\Vert{\mathbi{w}}\Vert}_1 \\
			     & =  &\sum_{w_i}|w_i| \nonumber
\label{eq:13-3}
\end{eqnarray}

\parinterval L2正则化是指
\begin{eqnarray}
R(\mathbi{w}) & = & ({\Vert{\mathbi{w}}\Vert}_2)^2 \\
			     & =  &\sum_{w_i}{w_i}^2 \nonumber
\label{eq:13-4}
\end{eqnarray}

\parinterval {\chapternine}已经介绍了L1和L2正则化方法，这里做一些展开。从几何的角度看，L1和L2正则项都是有物理意义的。二者都可以被看作是空间上的一个区域，比如，在二维平面上，$l_1$范数表示一个以0点为中心的菱形，$l_2$范数表示一个以0点为中心的圆。此时，$L(\mathbi{w})$和$R(\mathbi{w})$叠加在一起构成了一个新的区域，优化问题可以被看作是在这个新的区域上进行优化。由于L1和L2正则项都是在0点（坐标原点）附近形成的区域，因此优化的过程可以确保参数不会偏离0点太多。也就是说，L1和L2正则项引入了一个先验：模型的解不应该离0点太远。而L1和L2正则项实际上是在度量这个距离。

\parinterval 那为什么要用L1和L2正则项惩罚离0点远的解呢？这还要从模型复杂度谈起。实际上，对于神经机器翻译这样的模型来说，模型的容量是足够的。所谓容量可以被简单的理解为独立参数的个数 \footnote{另一种定义是把容量看作神经网络所能表示的假设空间大小\upcite{DBLP:journals/nature/LeCunBH15}，也就是神经网络能表示的不同函数所构成的空间。}。也就是说，理论上存在一种模型可以完美的描述问题。但是，从目标函数拟合的角度来看，如果一个模型可以拟合很复杂的目标函数，那模型所表示的函数形态也会很复杂。这往往体现在模型中参数的值“偏大”。比如，用一个多项式函数拟合一些空间中的点，如果希望拟合得很好，各个项的系数往往是非零的。而且为了对每个点进行拟合，通常需要多项式中的某些项具有较大的系数，以期望函数在局部有较大的斜率。显然，这样的模型是很复杂的。模型的复杂度可以用函数中参数（比如多项式中各项的系数）的“值”进行度量，这也体现在模型参数的范数上。

\parinterval 因此，L1和L2正则项的目的是防止模型为了匹配少数（噪声）样本而导致模型参数的值过大。反过来说，L1和L2正则项会鼓励那些参数值在0点附近的情况。从实践的角度看，这种方法可以很好的对统计模型的训练进行校正，得到泛化能力更强的模型。

%----------------------------------------------------------------------------------------
%    NEW SUB-SECTION
%----------------------------------------------------------------------------------------

\subsection{标签平滑}

\parinterval 神经机器翻译在每个目标语言位置$j$会输出一个分布$\hat{\mathbi{y}}_j$，这个分布描述了每个目标语言单词出现的可能性。在训练时，每个目标语言位置上的答案是一个单词，也就对应了One-hot 分布${\mathbi{y}}_j$，它仅仅在正确答案那一维为1，其它维均为0。模型训练可以被看作是一个调整模型参数让$\hat{\mathbi{y}}_j$逼近${\mathbi{y}}_j$的过程。但是，${\mathbi{y}}_j$的每一个维度是一个非0即1的目标，这样也就无法考虑类别之间的相关性。具体来说，除非模型在答案那一维输出1，否则都会得到惩罚。即使模型把一部分概率分配给与答案相近的单词（比如同义词），这个相近的单词仍被视为完全错误的预测。

\parinterval 标签平滑的思想很简单\upcite{Szegedy_2016_CVPR}：答案所对应的单词不应该“独享”所有的概率，其它单词应该有机会作为答案。这个观点与{\chaptertwo}中语言模型的平滑非常类似。在复杂模型的参数估计中，往往需要给未见或者低频事件分配一些概率，以保证模型具有更好的泛化能力。具体实现时，标签平滑使用了一个额外的分布$\mathbi{q}$，它是在词汇表$V$ 上的一个均匀分布，即$\mathbi{q}_k=\frac{1}{|V|}$，其中$\mathbi{q}_k$表示分布的第$k$维。然后，标准答案的分布被重新定义为${\mathbi{y}}_j$和$\mathbi{q}$的线性插值：
\begin{eqnarray}
\mathbi{y}_{j}^{ls} &=& (1-\alpha) \cdot {\mathbi{y}}_j + \alpha \cdot \mathbi{q}
\label{eq:13-5}
\end{eqnarray}

\noindent 这里，$\alpha$表示一个系数，用于控制分布$\mathbi{q}$的重要性，$\mathbi{y}_{j}^{ls}$表示使用标签平滑后的学习目标。

\parinterval 标签平滑实际上定义了一种“软”标签，使得所有标签都可以分到一些概率。一方面可以缓解数据中噪声的影响，另一方面目标分布会更合理（显然，真实的分布不应该是One-hot分布）。图\ref{fig:13-5}展示了标签平滑前后的损失函数计算结果的对比。

%----------------------------------------------
\begin{figure}[htp]
\centering
\input{./Chapter13/Figures/figure-label-smoothing}
\caption{不使用标签平滑 vs 使用标签平滑}
\label{fig:13-5}
\end{figure}
%----------------------------------------------

\parinterval 标签平滑也可以被看作是对损失函数的一种调整，并引入了额外的先验知识（即与$\mathbi{q}$相关的部分）。只不过这种先验知识并不是通过公式\eqref{eq:13-2}所示的线性插值方式与原始损失函数进行融合。

%----------------------------------------------------------------------------------------
%    NEW SUB-SECTION
%----------------------------------------------------------------------------------------

\subsection{Dropout}

\parinterval 神经机器翻译模型是一种典型的多层神经网络模型。每一层都包含若干神经元，负责接收前一层所有神经元的输出，之后进行诸如乘法、加法等变换操作，并有选择地使用非线性的激活函数，最终得到当前层每个神经元的输出。从模型最终预测的角度看，每个神经元都在参与最终的预测。理想的情况下，研究人员希望每个神经元都能相互独立的做出“贡献”。这样的模型会更加健壮，因为即使一部分神经元不能正常工作，其它神经元仍然可以独立做出合理的预测。但是，随着每一层神经元数量的增加以及网络结构的复杂化，神经元之间会出现{\small\bfnew{相互适应}}\index{相互适应}（Co-adaptation）\index{Co-adaptation}的现象。所谓相互适应是指，一个神经元对输出的贡献与同一层其它神经元的行为是相关的，也就是说这个神经元已经适应到它周围的“环境”中。

\parinterval 相互适应的好处在于神经网络可以处理更加复杂的问题，因为联合使用两个神经元要比单独使用每个神经元的表示能力强。这也类似于传统机器学习任务中往往会设计一些高阶特征，比如自然语言序列标注中对2-gram和3-gram的使用。不过另一方面，相互适应会导致模型变得更加“脆弱”。因为相互适应的神经元可以更好的描述训练数据中的现象，但是在测试数据上，由于很多现象是未见的，细微的扰动会导致神经元无法适应。具体体现出来就是过拟合问题。

\parinterval Dropout也是解决过拟合问题的一种常用方法\upcite{DBLP:journals/corr/abs-1207-0580}。该方法很简单，在训练时随机让一部分神经元停止工作，这样每次参数更新中每个神经元周围的环境都在变化，它就不会过分适应到环境中。图\ref{fig:13-6}中给出了某一次参数更新中使用Dropout之前和之后神经网络的状态对比。

%----------------------------------------------
\begin{figure}[htp]
\centering
\input{./Chapter13/Figures/figure-network-with-dropout}
\caption{使用Dropout之前（左）和之后（右）神经网络状态的对比}
\label{fig:13-6}
\end{figure}
%----------------------------------------------

\parinterval 具体实现时，可以设置一个参数$p \in (0,1)$。在每次参数更新所使用的前向和反向计算中，每个神经元都以概率$p$停止工作。相当于每层神经网络会有以$p$为概率的神经元被“屏蔽”掉。每一次参数更新中会随机屏蔽不同的神经元，图\ref{fig:13-7}给出了Dropout方法和传统方法计算方式的对比。其中，$x_{i}^{l}$代表第$l$层神经网络的第$i$个输入，$w_{i}^{l}$为输入所对应的权重，$b^{l}$表示第$l$层神经网络输入的偏置，$z_{i}^{l+1}$表示第$l$层神经网络的线性运算的结果，$f(\cdot)$表示激活函数，$r_{i}^{l}$的值服从于参数为$1-p$的伯努利分布。

%----------------------------------------------
\begin{figure}[htp]
\centering
\input{./Chapter13/Figures/figure-computation-of-dropout}
\caption{使用Dropout之前（左）和之后（右）一层神经网络}
\label{fig:13-7}
\end{figure}
%----------------------------------------------

\parinterval 对于新的样本，可以使用Dropout训练之后的模型对其进行推断，但是每个神经元的输出要乘以$1-p$，以保证每层神经元输出的期望和训练时是一样的。另一种常用的做法是，在训练时对每个神经元的输出乘以$\frac{1}{1-p}$，然后在推断时神经网络可以不经过任何调整就直接使用。

\parinterval Dropout方法的另一种解释是，在训练中屏蔽掉一些神经元相当于从原始的神经网络中抽取出了一个子网络。这样，每次训练都在一个随机生成的子网络上进行，而不同子网络之间的参数是共享的。在推断时，则把所有的子网络集成到一起。这种思想也有一些{\small\bfnew{集成学习}}\index{集成学习}（Ensemble Learning）\index{Ensemble Learning}的味道，只不过Dropout中子模型（或子网络）是在指数级空间中采样出来的。由于Dropout可以很好的缓解复杂神经网络模型的过拟合问题，因此也成为了大多数神经机器翻译系统的标配。

\parinterval 随着网络层数的增多，相互适应也会出现在不同层之间，甚至会出现在多头注意力机制的不同头之间。因此，Dropout方法也可以用于对模型局部结构的屏蔽，比如，对多层神经网络中的层进行屏蔽，即Layer Dropout。 特别是对于深层神经网络，Layer Dropout 也是一种有效的防止过拟合的方法。关于Layer Dropout的内容在{\chapterfifteen}还会有详细讨论。

%----------------------------------------------------------------------------------------
%    NEW SECTION
%----------------------------------------------------------------------------------------

\sectionnewpage
\section{对抗样本训练}
\label{sec:adversarial-examples}

\parinterval 同其它基于神经网络的方法一样，提高{\small\bfnew{健壮性}}\index{健壮性}（Robustness）\index{Robustness}也是神经机器翻译研发中需要关注的。比如，大容量模型可以很好地拟合训练数据，但是当测试样本与训练样本差异较大时，会导致很糟糕的翻译结果\upcite{JMLR:v15:srivastava14a,DBLP:conf/amta/MullerRS20}。另一方面，实践中也发现，有些情况下即使输入中有微小的扰动，神经网络模型的输出也会产生巨大变化。或者说，神经网络模型在输入样本上容易受到攻击（Attack）\upcite{DBLP:conf/sp/Carlini017,DBLP:conf/cvpr/Moosavi-Dezfooli16,DBLP:conf/acl/ChengJM19}。表\ref{tab:13-1}展示了一个神经机器翻译系统的翻译结果，可以看到，把输入句子中的单词“jumped”换成“sunk”会得到完全不同的译文。这时神经机器翻译系统就存在健壮性问题。

%----------------------------------------------
\begin{table}[htp]{
\begin{center}
\caption{神经机器翻译实例} \label{tab:13-1}
\begin{tabular}{l | l}
\rule{0pt}{15pt} 原始输入 & When shot at, the dove jumped into the bushes \\
\hline

\rule{0pt}{15pt} 原始输出 & 当鸽子被射中时，它跳进了灌木丛 \\
\rule{0pt}{15pt} 扰动的输入 & When shot at, the dove {\red sunk} into the bushes \\
\hline
\rule{0pt}{15pt} 扰动的输出 & 当有人开枪射击时，那只鸽子陷进了灌木丛中 \\
\end{tabular}
\end{center}
}\end{table}
%-------------------------------------------

\parinterval 决定神经网络模型健壮性的因素主要包括训练数据、模型结构、正则化方法等。仅仅从模型的角度来改善健壮性一般是较为困难的，因为如果输入数据是“干净”的，模型就会学习如何在这样的数据上进行预测。无论模型的能力是强还是弱，当推断时的输入数据出现扰动的时候，模型可能就无法适应这种它从未见过的新数据。因此，一种简单直接的方法是从训练样本出发，让模型在学习的过程中能对样本中的扰动进行处理，进而在推断时更加健壮。具体来说，可以在训练过程中构造有噪声的样本，即基于{\small\bfnew{对抗样本}}\index{对抗样本}（Adversarial Examples）\index{Adversarial Examples}进行{\small\bfnew{对抗训练}}\index{对抗训练}（Adversarial Training）\index{Adversarial Training}。

%----------------------------------------------------------------------------------------
%    NEW SUB-SECTION
%----------------------------------------------------------------------------------------

\subsection{对抗样本及对抗攻击}

\parinterval 在图像识别领域，研究人员就发现，对于输入图像的细小扰动，如像素变化等，会使模型以高置信度给出错误的预测\upcite{DBLP:conf/cvpr/NguyenYC15,DBLP:journals/corr/SzegedyZSBEGF13,DBLP:journals/corr/GoodfellowSS14}，但是这种扰动并不会造成人类的错误判断。也就是说，样本中的微小变化“欺骗”了图像识别系统，但是“欺骗”不了人类。这种现象背后的原因有很多，一种可能的原因是：系统并没有理解图像，而是在拟合数据，因此拟合能力越强，反而对数据中的微小变化更加敏感。从统计学习的角度看，既然新的数据中可能会有扰动，那更好的学习方式就是在训练中显性地把这种扰动建模出来，让模型对输入的细微变化表现得更加健壮。

\parinterval 这种通过在原样本上增加一些难以察觉的扰动，从而使模型得到错误判断的样本被称为对抗样本。对于模型的输入$\mathbi{x}$和输出$\mathbi{y}$，对抗样本形式上可以被描述为：
\begin{eqnarray}
\funp{C}(\mathbi{x}) &=& \mathbi{y}
\label{eq:13-6}\\
\funp{C}(\mathbi{x}') &\neq& \mathbi{y}
\label{eq:13-7}\\
\textrm{s.t.} \quad \Psi(\mathbi{x},\mathbi{x}') &<& \varepsilon
\label{eq:13-8}
\end{eqnarray}

\noindent 其中，$(\mathbi{x}',\mathbi{y})$为输入中含有扰动的对抗样本，函数$\funp{C}(\cdot)$为模型。公式\eqref{eq:13-8}中$\Psi(\mathbi{x},\mathbi{x}')$表示扰动后的输入$\mathbi{x}'$和原输入$\mathbi{x}$之间的距离，$\varepsilon$表示扰动的受限范围。当模型对包含噪声的数据容易给出较差的结果时，往往意味着该模型的抗干扰能力差，因此可以利用对抗样本检测现有模型的健壮性\upcite{DBLP:conf/emnlp/JiaL17}。同时，采用类似数据增强的方式将对抗样本混合至训练数据中，能够使模型得到稳定的预测能力，这种方式也被称为对抗训练\upcite{DBLP:journals/corr/GoodfellowSS14,DBLP:conf/emnlp/BekoulisDDD18,DBLP:conf/naacl/YasunagaKR18}。

\parinterval 通过对抗样本训练来提升模型健壮性的首要问题是：如何生成对抗样本。通过当前模型$\funp{C}$和样本$(\mathbi{x},\mathbi{y})$，生成对抗样本的过程被称为{\small\bfnew{对抗攻击}}\index{对抗攻击}（Adversarial Attack）\index{Adversarial Attack}。对抗攻击可以被分为黑盒攻击和白盒攻击。在白盒攻击中，攻击算法可以访问模型的完整信息，包括模型结构、网络参数、损失函数、激活函数、输入和输出数据等。黑盒攻击通常依赖启发式方法来生成对抗样本\upcite{DBLP:conf/emnlp/JiaL17}，由于这种攻击方式不需要知道神经网络的详细信息，仅仅通过访问模型的输入和输出就可以达到攻击的目的。并且由于神经网络其本身便是一个黑盒模型，因此在神经网络的相关应用中黑盒攻击方法更加实用。

\parinterval 在神经机器翻译中，训练数据中含有的细微扰动会使得模型比较脆弱\upcite{DBLP:conf/iclr/BelinkovB18}。研究人员希望借鉴图像任务中的一些对抗攻击方法，并将其应用于自然语言处理任务中。然而，对计算机而言，以像素值等表示的图像数据本身就是连续的\upcite{DBLP:conf/naacl/MichelLNP19}，而文本中的一个个单词本身离散的，这种图像与文本数据间的差异使得这些方法在自然语言处理上并不适用。比如图像任务中对一幅图片的局部图像进行替换的方法，如果用于自然语言处理中，可能会生成语法错误或者语义错误的句子。而且，简单替换单词产生的扰动过大，模型很容易判别。即使对词嵌入等连续表示的部分进行扰动，也会产生无法与词嵌入空间中的任何词匹配的向量\upcite{Gong2018AdversarialTW}。针对这些问题，下面着重介绍神经机器翻译任务中如何有效生成、使用对抗样本。

%----------------------------------------------------------------------------------------
%    NEW SUB-SECTION
%----------------------------------------------------------------------------------------

\subsection{基于黑盒攻击的方法}

\parinterval 一个好的对抗样本应该具有这种性质：对文本做最少的修改，并最大程度地保留原文的语义。一种简单的实现方式是对文本加噪声。这里，噪声可以分为自然噪声和人工噪声\upcite{DBLP:conf/iclr/BelinkovB18}。自然噪声一般是指在语料库中自然出现的错误，如输入错误、拼写错误等。人为噪声是通过人工设计的自动方法修改文本，例如，可以通过规则或是噪声生成器，在干净的数据中以一定的概率引入拼写错误、语法错误等\upcite{DBLP:conf/naacl/VaibhavSSN19,DBLP:conf/naacl/AnastasopoulosL19,DBLP:conf/acl/SinghGR18}；此外，也可以在文本中加入人为设计过的毫无意义的单词序列。

\parinterval 除了单纯的在文本中引入各种扰动外，还可以通过文本编辑的方式，在不改变语义的情况下尽可能修改文本，从而构建对抗样本\upcite{DBLP:journals/corr/SamantaM17,DBLP:conf/ijcai/0002LSBLS18}。文本的编辑方式主要包括交换、插入、替换和删除操作。表\ref{tab:13-2}给出了通过这几种方式生成对抗样本的例子。

%----------------------------------------------
\begin{table}[htp]{
\begin{center}
\caption{对抗样本实例} \label{tab:13-2}
\begin{tabular}{l | l }
\rule{0pt}{15pt} 原始输入 & We are really looking forward to the holiday \\
\hline

\rule{0pt}{15pt} 替换操作 & We are really looking forward to the  {\red vacation} \\
\rule{0pt}{15pt} 插入操作 & We are really looking forward to the holiday {\red tomorrow} \\
\rule{0pt}{15pt} 删除操作 & We are really looking forward {\red \st{to}} the holiday \\
\rule{0pt}{15pt} 交换操作 & We are really {\red forward} {\red looking} to the holiday \\
\end{tabular}
\end{center}
}\end{table}
%-------------------------------------------

\parinterval 形式上，可以利用如FGSM等算法\upcite{DBLP:journals/corr/GoodfellowSS14}，验证文本中每一个单词的贡献度，同时为每一个单词构建一个候选池，包括该单词的近义词、拼写错误词、同音词等。对于贡献度较低的词，如语气词、副词等，可以使用插入、删除操作进行扰动。对于其他的单词，可以在候选池中选择相应的单词并进行替换。其中，交换操作可以是基于词级别的，比如交换序列中的单词，也可以是基于字符级别的，例如交换单词中的字符\upcite{DBLP:conf/coling/EbrahimiLD18}。重复进行上述的编辑操作，直至编辑出的文本可以误导模型做出错误的判断。

\parinterval 在机器翻译中，常用的回译技术也是生成对抗样本的一种有效方式。回译就是，通过反向模型将目标语言翻译成源语言，并将翻译得到的双语数据用于模型训练（见{\chaptersixteen}）。除了翻译模型，语言模型也可以用于生成对抗样本。{\chaptertwo}已经介绍过，语言模型可以用于检测句子的流畅度，它根据上文预测当前位置可能出现的单词。因此，此时可以使用语言模型预测出当前位置最可能出现的多个单词，并用这些词替换序列中原本的单词。在机器翻译任务中，可以通过与神经机器翻译系统联合训练，共享词向量矩阵的方式得到语言模型\upcite{DBLP:conf/acl/GaoZWXQCZL19}。

\parinterval 此外，{\small\bfnew{生成对抗网络}}\index{生成对抗网络}（Generative Adversarial Networks\index{Generative Adversarial Networks}，GANs）也可以被用来生成对抗样本\upcite{DBLP:conf/iclr/ZhaoDS18}。与回译方法类似，基于生成对抗网络的方法将原始的输入映射为潜在分布$\funp{P}$，并在其中搜索出服从相同分布的文本构成对抗样本。一些研究也对这种方法进行了优化\upcite{DBLP:conf/iclr/ZhaoDS18}，在稠密的向量空间中进行搜索，也就是说在定义$\funp{P}$的基础稠密向量空间中找到对抗性表示$\mathbi{z}'$，然后利用生成模型将其映射回$\mathbi{x}'$，使最终生成的对抗样本在语义上接近原始输入。

%----------------------------------------------------------------------------------------
%    NEW SUB-SECTION
%----------------------------------------------------------------------------------------

\subsection{基于白盒攻击的方法}

\parinterval 除了在单词级别增加扰动以外，还可以在模型内部增加扰动。一种简单的方法是在每一个词的词嵌入上，累加一个正态分布的变量，之后将其作为模型的最终输入。同时，可以在训练阶段增加额外的训练目标。比如，迫使模型在接收到被扰动的输入后，编码器能够生成与正常输入类似的表示，解码器输出正确的翻译结果\upcite{DBLP:conf/acl/LiuTMCZ18}。

\parinterval 还可以根据机器翻译的具体问题增加扰动。例如，针对同音字错误问题，可以将单词的发音转换为一个包含$n$个发音单元的发音序列，如音素，音节等，并训练相应的嵌入矩阵将每一个发音单元转换为对应的向量表示。对发音序列中发音单元的嵌入表示进行平均后，得到当前单词的发音表示。最后将词嵌入与单词的发音表示进行加权求和，并将结果作为模型的输入\upcite{DBLP:conf/acl/LiuMHXH19}。通过这种方式可以提高模型对同音异形词的处理能力。除了在词嵌入层增加扰动，也可以在编码器输出中引入额外的噪声，能起到与在层输入中增加扰动相类似的效果\upcite{DBLP:conf/acl/LiLWJXZLL20}。

\parinterval 此外，对于训练样本$(\mathbi{x},\mathbi{y})$，还可以使用基于梯度的方法来生成对抗样本$(\mathbi{x}',\mathbi{y}')$。例如，可以利用替换词与原始单词词向量之间的差值，以及候选词的梯度之间的相似度来生成对抗样本\upcite{DBLP:conf/acl/ChengJM19}。以源语言为例，生成$\mathbi{x}'$中第$i$个词的过程可以被描述如下：
\begin{eqnarray}
{{x}'}_i &=& \argmax_{{x}\in V}\textrm{sim}(\funp{e}({x})-\funp{e}({x}_i),\mathbi{g}_{{x}_i})
\label{eq:13-9} \\
\mathbi{g}_{{x}_i} &=&  \bigtriangledown_{\funp{e}({x}_i)} - \log \funp{P}(\mathbi{y}|\mathbi{x};\theta)
\label{eq:13-10}
\end{eqnarray}

\noindent 其中，${x}_i$为输入序列中的第$i$个词，$\funp{e}(\cdot)$用于获取词向量，$\mathbi{g}_{{x}_i}$为翻译概率相对于$e({x}_i)$的梯度，$\textrm{sim}(\cdot,\cdot)$是用于评估两个向量之间相似度（距离）的函数，$V$为源语言的词表。由于对词表中所有单词进行枚举时，计算成本较大。因此可以利用语言模型选择最可能的$n$ 个词作为候选，并从中采样出单词完成替换。同时，为了保护模型不受解码器预测误差的影响，此时需要对模型目标语言端的输入做出同样的调整。与源语言端的操作不同，此时会将公式\eqref{eq:13-10}中的损失替换为$- \log \funp{P}(\mathbi{y}|\mathbi{x}')$，即使用生成的对抗样本$\mathbi{x}'$计算翻译概率。

\parinterval 在进行对抗性训练时，可以在原有的训练损失上增加三个额外的损失，最终的损失函数被定义为：
\begin{eqnarray}
\textrm{Loss}(\theta_{\textrm{mt}},\theta_{\textrm{lm}}^{\mathbi{x}},\theta_{\textrm{lm}}^{\mathbi{y}}) &=& \textrm{Loss}_{\textrm{clean}}(\theta_{\textrm{mt}}) + \textrm{Loss}_{\textrm{lm}}(\theta_{\textrm{lm}}^{\mathbi{x}}) + \nonumber \\
& & \textrm{Loss}_{\textrm{robust}}(\theta_{\textrm{mt}}) + \textrm{Loss}_{\textrm{lm}}(\theta_{\textrm{lm}}^{\mathbi{y}})
\label{eq:13-11}
\end{eqnarray}

\noindent 其中，$\textrm{Loss}_{\textrm{clean}}(\theta_{\textrm{mt}})$为正常情况下的损失，$\textrm{Loss}_{\textrm{lm}}(\theta_{\textrm{lm}}^{\mathbi{x}})$和$\textrm{Loss}_{\textrm{lm}}(\theta_{\textrm{lm}}^{\mathbi{y}})$为生成对抗样本所用到的源语言与目标语言的模型的损失，$\textrm{Loss}_{\textrm{robust}}(\theta_{\textrm{mt}})$是使用修改后得到的对抗样本作为输入，并以原始的译文$\mathbi{y}$作为答案时计算得到的损失。假设有$N$个样本，则损失函数的具体形式如下：
\begin{eqnarray}
\textrm{Loss}_{\textrm{robust}}(\theta_{\textrm{mt}}) &=&  \frac{1}{N}\sum_{(\mathbi{x},\mathbi{y})}-\log \funp{P}(\mathbi{y}|\mathbi{x}',\mathbi{y}';\theta_{\textrm{mt}})
\label{eq:13-12}
\end{eqnarray}

\parinterval 无论是黑盒方法还是白盒方法，本质上都是通过增加噪声使得模型训练更加健壮。类似的思想在很多机器学习方法中都有体现，比如，在最大熵模型中使用高斯噪声就是常用的增加模型健壮性的手段之一\upcite{chen1999gaussian}。从噪声信道模型的角度看（见{\chapterfive}），翻译过程也可以被理解为一种加噪和去噪的过程，不论这种噪声是天然存在于数据中的，还是人为添加的。除了对抗样本训练，机器翻译所使用的降噪自编码方法和基于重构的损失函数\upcite{DBLP:conf/icml/VincentLBM08,tu2017neural}，也都体现了类似的思想。广义上，这些方法也可以被看作是利用“加噪+ 去噪”进行健壮性训练的方法。

%----------------------------------------------------------------------------------------
%    NEW SECTION
%----------------------------------------------------------------------------------------

\sectionnewpage
\section{学习策略}

\parinterval 尽管极大似然估计在神经机器翻译中取得了巨大的成功，但仍然面临着许多问题。比如，似然函数并不是评价翻译系统性能的指标，这使得即使在训练数据上优化似然函数，但在应用模型时并不一定可以获得更好的翻译结果。本节首先会对极大似然估计的问题进行论述，然后介绍一些解决相关问题的方法。

%----------------------------------------------------------------------------------------
%    NEW SUB-SECTION
%----------------------------------------------------------------------------------------

\subsection{极大似然估计的问题}\label{subsec-13.3.1}

\parinterval 极大似然估计已成为机器翻译乃至整个自然语言处理领域中使用最广泛的训练用目标函数。但是，使用极大似然估存在{\small\bfnew{曝光偏置}}\index{曝光偏置}（Exposure Bias\index{Exposure Bias}）问题和训练-推断评价指标不一致问题，具体体现在如下两个方面。

\begin{itemize}
\vspace{0.5em}
\item {\small\bfnew{曝光偏置问题}}。在训练过程中，模型使用标注数据进行训练，因此模型在预测下一个单词时，解码器的输入是正确的译文片段。也就是，预测第$j$个单词时，系统使用了标准答案$\{{y}_1,...,{y}_{j-1}\}$作为历史信息。但是对新的句子进行翻译时，预测第$j$个单词时使用的是模型自己生成的前$j-1$个单词，即$\{\hat{{y}}_1,...,\hat{{y}}_{j-1}\}$。这意味着，训练时使用的输入数据（目标语言端）与真实翻译时的情况不符，如图\ref{fig:13-8}所示。由于在训练过程中暴露于标注数据，因此模型也适应了标注数据，在推断阶段无法很好地适应模型自动生成的数据，这就是曝光偏置问题\upcite{Bengio2015ScheduledSF,Ranzato2016SequenceLT}。
\vspace{0.5em}

%----------------------------------------------
\begin{figure}[t]
\centering
\input{./Chapter13/Figures/figure-exposure-bias}
\caption{曝光偏置问题（基于循环神经网络的翻译模型）}
\label{fig:13-8}
\end{figure}
%----------------------------------------------

\item {\small\bfnew{训练目标函数与任务评价指标不一致问题}}。在训练数据上使用极大似然估计，而在新数据上进行推断的时候，通常使用BLEU等外部评价指标来评价模型的性能。在机器翻译任务中，这个问题的一种体现是，训练数据上更低的困惑度不一定能带来BLEU的提升。更加理想的情况是，模型应该直接最大化性能评价指标，而不是训练集数据上的似然函数\upcite{DBLP:conf/acl/ShenCHHWSL16}。但是很多模型性能评价指标不可微分，这使得研究人员无法直接利用基于梯度的方法来优化这些指标。
\vspace{0.5em}
\end{itemize}

%----------------------------------------------------------------------------------------
%    NEW SUB-SECTION
%----------------------------------------------------------------------------------------

\subsection{非Teacher-forcing方法}

\parinterval 所谓Teacher-forcing方法，即要求模型预测的结果和标准答案完全对应。Teacher-forcing是一种深度学习中的训练策略，在序列处理任务上被广泛使用\upcite{DBLP:journals/nature/LeCunBH15}。以序列生成任务为例，Teacher-forcing要求模型在训练时不是使用上一个时刻的模型输出作为下一个时刻的输入，而是使用训练数据中上一时刻的标准答案作为下一个时刻的输入。显然，这会导致曝光偏置问题。为了解决这个问题，可以使用非Teacher-forcing方法。比如，在训练中使用束搜索，这样可以让训练过程模拟推断时的行为。具体来说，非Teacher-forcing方法可以用调度采样和生成对抗网络进行实现。

%----------------------------------------------------------------------------------------
%    NEW SUBSUB-SECTION
%----------------------------------------------------------------------------------------

\subsubsection{1. 调度采样}

\parinterval 对于一个目标语言序列$\seq{y}=\{{y}_1,\ldots,{y}_n\}$，在预测第$j$个单词时，训练过程与推断过程之间的主要区别在于：训练过程中使用标准答案$\{{y}_{1},...,{y}_{j-1}\}$，而推断过程使用的是来自模型本身的预测结果$\{\hat{{y}}_{1},...,\hat{{y}}_{j-1}\}$。此时可以采取一种{\small\bfnew{调度采样}}\index{调度采样}（Scheduled Sampling\index{Scheduled Sampling}）机制\upcite{Bengio2015ScheduledSF}。以基于循环神经网络的模型为例，在训练中预测第$j$个单词时，随机决定使用${y}_{j-1}$还是$\hat{{y}}_{j-1}$作为输入。 假设训练时使用的是基于小批量的随机梯度下降方法，在第$i$ 个批次中，对序列每一个位置进行预测时以概率$\epsilon_i$使用标准答案${y}_{j-1}$，或以概率${1-\epsilon_i}$使用来自模型本身的预测$\hat{{y}}_{j-1}$。具体到序列中的一个位置$j$，可以根据模型单词预测的概率进行采样，在$\epsilon_i$控制的调度策略下，同${y}_{j-1}$一起作为输入。此过程如图\ref{fig:13-9}所示，并且这个过程可以很好地与束搜索融合。

%----------------------------------------------
\begin{figure}[htp]
\centering
\input{./Chapter13/Figures/figure-of-scheduling-sampling-method}
\caption{调度采样方法的示意图}
\label{fig:13-9}
\end{figure}
%----------------------------------------------

\parinterval 当$\epsilon_i=1$时，模型的训练与原始的训练策略完全相同，而当$\epsilon_i=0$时，模型的训练则与推断时使用的策略完全一样。在这里使用到了一种{\small\bfnew{课程学习}}\index{课程学习}（Curriculum Learning）\index{curriculum learning}策略\upcite{DBLP:conf/coling/XuHJFWHJXZ20}，该策略认为学习应该循序渐进，从一种状态逐渐过渡到另一种状态。在训练开始时，由于模型训练不充分，因此如果使用模型预测结果作为输入，会导致收敛速度非常慢。因此，在模型训练的前期，通常会选择使用标准答案$\{{y}_{1},...,{y}_{j-1}\}$。在模型训练的后期，应该更倾向于使用自模型本身的预测$\{\hat{{y}}_{1},...,\hat{{y}}_{j-1}\}$。关于课程学习的内容在\ref{sec:curriculum-learning}节还会有详细介绍。

\parinterval 在使用调度策略时，需要调整关于训练批次$i$的函数来降低$\epsilon_i$，与梯度下降方法中降低学习率的方式相似。调度策略可以采用如下几种方式：

\begin{itemize}
\vspace{0.5em}
\item {\small\bfnew{线性衰减}}。$\epsilon_i = \max⁡(\epsilon,k-ci)$，其中$\epsilon$（$0 \leqslant \epsilon < 1$）是$\epsilon_i$的最小数值，而$k$和$c$代表衰减的偏移量和斜率，取决于预期的收敛速度。
\vspace{0.5em}
\item {\small\bfnew{指数衰减}}。$\epsilon_i = k^i$，其中$k$是一个常数，一般为$k < 1$。
\vspace{0.5em}
\item {\small\bfnew{反向Sigmoid 衰减}}。$\epsilon_i = k/(k + \exp⁡(i/k))$，其中$k \geqslant 1$。
\vspace{0.5em}
\end{itemize}

%----------------------------------------------------------------------------------------
%    NEW SUBSUB-SECTION
%----------------------------------------------------------------------------------------

\subsubsection{2. 生成对抗网络}

\parinterval 调度采样解决曝光偏置的方法是，把模型前$j-1$步的预测结果作为输入，来预测第$j$步的输出。但是，如果模型预测的结果中有错误，再使用错误的结果预测未来的序列也会产生问题。解决这个问题就需要知道模型预测的好与坏，并在训练中有效的使用它们。如果生成好的结果，那么可以使用它进行模型训练，否则就不使用。生成对抗网络就是这样一种技术，它引入了一个额外的模型（判别器）来对原有模型（生成器）的生成结果进行评价，并根据评价结果同时训练两个模型。

\parinterval 在\ref{sec:adversarial-examples}小节已经提到了生成对抗网络，这里稍微进行一些展开。 在机器翻译中，基于对抗神经网络的架构被命名为{\small\bfnew{对抗神经机器翻译}}\index{对抗神经机器翻译}（Adversarial-NMT）\index{Adversarial-NMT}\upcite{DBLP:conf/acml/WuXTZQLL18}。这里，令$(\seq{x},\seq{y})$表示一个训练样本，令$\hat{\seq{y}}$ 表示神经机器翻译系统对源语言句子$\seq{x}$ 的翻译结果。此时，对抗神经机器翻译的总体框架可以表示为图\ref{fig:13-10}，其中。绿色部分表示神经机器翻译模型$G$，该模型将源语言句子$\seq{x}$翻译为目标语言句子$\hat{\seq{y}}$。红色部分是对抗网络$D$，它的作用是判断目标语言句子是否是源语言句子$\seq{x}$ 的真实翻译。$G$和$D$相互对抗，用$G$生成的翻译结果$\hat{\seq{y}}$来训练$D$，并生成奖励信号，再使用奖励信号通过策略梯度训练$G$。

%----------------------------------------------
\begin{figure}[htp]
\centering
\input{./Chapter13/Figures/figure-framework-of-Adversarial-Neural-machine-translation}
\caption{对抗神经机器翻译框架图}
\label{fig:13-10}
\end{figure}
%----------------------------------------------

\parinterval 实际上，对抗神经机器翻译的训练目标就是强制$\hat{\seq{y}}$ 与$\seq{y}$ 相似。在理想情况下，$\hat{\seq{y}}$与人类标注的答案$\seq{y}$非常相似，以至于人类也无法分辨$\hat{\seq{y}}$是由机器还是人类产生的。

%----------------------------------------------------------------------------------------
%    NEW SUB-SECTION
%----------------------------------------------------------------------------------------

\subsection{强化学习方法}

\parinterval {\small\bfnew{强化学习}}\index{强化学习}（Reinforcement Learning\index{Reinforcement Learning}，RL）方法是机器学习中的经典方法，它可以同时解决\ref{subsec-13.3.1}节提到的曝光偏置问题和训练-推断评价指标不一致问题。本节主要介绍基于策略的方法和基于演员-评论家的方法\upcite{DBLP:conf/iclr/BahdanauBXGLPCB17}。

%----------------------------------------------------------------------------------------
%    NEW SUBSUB-SECTION
%----------------------------------------------------------------------------------------

\subsubsection{1. 基于策略的方法}

\parinterval {\small\bfnew{最小风险训练}}\index{最小风险训练}（Minimum Risk Training\index{Minimum Risk Training}，MRT）可以被看作是一种基于策略的方法。与极大似然估计不同，最小风险训练引入了评价指标作为损失函数，并优化模型将预期风险降至最低\upcite{DBLP:conf/acl/ShenCHHWSL16}。

\parinterval 最小风险训练的目标是找到模型参数$\hat{\theta}_{\textrm{MRT}} $，满足如下公式：
\begin{eqnarray}
\hat{\theta}_{\textrm{MRT}} & = & \argmin_{\theta}\{\funp{R}(\theta)\} \label{eq:13-13}
\end{eqnarray}

\noindent 其中，$\funp{R}(\theta)$表示预期风险，通常用风险函数的期望表示。假设有$N$个训练样本$\{(x^{[1]},y^{[1]}),...,(x^{[N]},y^{[N]})\}$，$\funp{R}(\theta)$被定义如下：
\begin{eqnarray}
\funp{R}(\theta) & = & \sum_{k=1}^N \mathbb{E}_{\hat{\seq{y}}|\seq{x}^{[k]};\theta}[\vartriangle(\hat{\seq{y}},\seq{y}^{[k]})] \nonumber \\
& = & \sum_{k=1}^N \sum_{\hat{\seq{y}} \in \chi(\seq{x}^{[k]})}\funp{P}(\hat{\seq{y}}|\seq{x}^{[k]};\theta)\vartriangle(\hat{\seq{y}},\seq{y}^{[k]})
\label{eq:13-14}
\end{eqnarray}

\noindent 这里，$\hat{\seq{y}}$是模型预测的译文，$\chi(\seq{x}^{[k]})$是$\seq{x}^{[k]}$所对应的所有候选翻译的集合。损失函数$\vartriangle(\hat{\seq{y}},\seq{y}^{[k]})$用来衡量模型预测$\hat{\seq{y}}$与标准答案$\seq{y}^{[k]}$间的差异，损失函数一般用翻译质量评价指标定义，例如，BLEU，TER等\footnote{对于BLEU，损失函数可以被定义为$1-$BLEU。}。在最小风险训练中，对模型参数$\theta$的偏导数为：
\begin{eqnarray}
\frac{\partial \funp{R}(\theta)}{\partial \theta} & = & \sum_{k=1}^N \mathbb{E}_{\hat{\seq{y}}|\seq{x}^{[k]};\theta}[\vartriangle(\hat{\seq{y}},\seq{y}^{[k]}) \times \frac{\partial \funp{P}(\hat{\seq{y}}|\seq{x}^{[k]};\theta)/\partial \theta}{\funp{P}(\hat{\seq{y}}|\seq{x}^{[k]};\theta)}] \nonumber \\
& = & \sum_{k=1}^N \mathbb{E}_{\hat{\seq{y}}|\seq{x}^{[k]};\theta}[\vartriangle(\hat{\seq{y}},\seq{y}^{[k]}) \times \frac{\partial \log{\funp{P}(\hat{\seq{y}}|\seq{x}^{[k]};\theta)}}{\partial \theta}]
\label{eq:13-15}
\end{eqnarray}

\noindent 公式\eqref{eq:13-15}使用了{\small\bfnew{策略梯度}}\index{策略梯度}（Policy Gradient\index{Policy Gradient}）的手段将$\vartriangle(\hat{\seq{y}},\seq{y}^{[k]})$提到微分操作之外\upcite{DBLP:conf/nips/Kakade01,DBLP:journals/corr/abs-1810-02525}。这样，就无需对$\vartriangle(\hat{\seq{y}},\seq{y}^{[k]})$进行微分，因此最小风险训练允许任意不可微的损失函数，包括BLEU等常用的评价函数。同时，等式右侧将对概率的求导操作转化为了对log函数的求导，更易于模型进行优化。因此，使用公式\eqref{eq:13-15}就可以求出模型参数相对于风险函数的损失，进而进行基于梯度的优化。

\parinterval 这里需要注意的是，公式\eqref{eq:13-15}中求期望的过程是无法直接实现的，因为无法遍历所有的译文句子。通常，会使用采样的方法搜集一定数量的译文，来模拟译文空间。例如，可以使用推断系统生成若干译文。同时，为了保证生成的译文之间具有一定的差异性，也可以对推断过程进行一些“干扰”。从实践的角度看，采样方法是影响强化学习系统的重要因素，因此往往需要对不同的任务设计相适应的采样方法。最简单的方法就是在产生译文的每一个词时候，根据模型产生的下一个词的分布随机选取词当作模型预测，直到选到句子结束符或者达到特定长度的时候停止\upcite{DBLP:conf/emnlp/EdunovOAG18}。其他方法还包括随机束搜索，它把束搜索中选取Top-$k$的操作替换成随机选取$k$个词。这个方法不会采集到重复的样本。还可以使用基于Gumbel-Top-$k$的随机束搜索更好地控制了样本里的噪声\upcite{DBLP:conf/icml/KoolHW19}。

\parinterval 相比于极大似然估计，最小风险训练有着以下优点：

\begin{itemize}
\vspace{0.5em}
\item 最小风险训练使用模型自身产生的数据进行训练，从而避免了曝光偏置问题。
\vspace{0.5em}
\item 最小风险训练直接优化BLEU等评价指标，从而解决了训练-推断评价指标不一致问题。
\vspace{0.5em}
\item 最小风险训练方法不涉及具体的模型结构，可以应用于任意的机器翻译模型。
\vspace{0.5em}
\end{itemize}

%----------------------------------------------------------------------------------------
%    NEW SUBSUB-SECTION
%----------------------------------------------------------------------------------------

\subsubsection{2. 演员-评论家方法}

\parinterval 基于策略的强化学习是要寻找一个策略$\funp{p}(a|\hat{{y}}_{1 \ldots j-1},\seq{x})$，使得该策略选择的行动$a$未来可以获得的奖励期望最大化，也被称为{\small\bfnew{动作价值函数}}\index{动作价值函数}（Action-value Function）\index{Action-value Function}最大化。这个过程通常用函数$Q$来描述：
\begin{eqnarray}
\funp{Q}(a;\hat{y}_{1 \ldots j-1},\seq{y}) & = & \mathbb{E}_{\hat{y}_{j+1 \ldots J} \sim \funp{p}(\cdot|\hat{y}_{1 \ldots j-1} a,\seq{x})}[\funp{r}_j(a;\hat{y}_{1 \ldots j-1},\seq{y}) + \nonumber \\
&  & \sum_{i=j}^J\funp{r}_i(\hat{{y}}_i;\hat{{y}}_{1 \ldots j-1}a\hat{{y}}_{j+1 \ldots i},\seq{y})]
\label{eq:13-16}
\end{eqnarray}

\noindent 其中，$\funp{r}_j(a;\hat{{y}}_{1 \ldots j-1},\seq{y})$是$j$时刻做出行动$a$获得的奖励，$\funp{r}_i(\hat{{y}}_i;\hat{{y}}_{1 \ldots j-1}a\hat{{y}}_{j+1 \ldots i},\seq{y})$是在$j$时刻的行动为$a$的前提下，$i$时刻的做出行动$\hat{{y}}_i$获得的奖励，$\hat{y}_{j+1 \ldots J} \sim \funp{p}(\cdot|\hat{y}_{1 \ldots j-1} a,\seq{x})$表示序列$\hat{y}_{j+1 \ldots J}$是根据$\funp{p}(\cdot|\hat{y}_{1 \ldots j-1} a,\seq{x})$得到的采样结果，概率函数$\funp{p}$中的$\cdot$表示序列$\hat{y}_{j+1 \ldots J}$服从的随机变量，$\seq{x}$是源语言句子，$\seq{y}$是正确译文，$\hat{{y}}_{1 \ldots j-1}$是策略$\funp{p}$产生的译文的前$j-1$个词，$J$是生成译文的长度。特别的，对于公式\ref{eq:13-16}中$\hat{{y}}_{j+1 \ldots i}$来说，如果$i<j+1$，则$\hat{{y}}_{j+1 \ldots i}$不存在，对于源语句子$x$，最优策略$\hat{p}$可以被定义为：
\begin{eqnarray}
\hat{p} & = & \argmax_{\funp{p}}\mathbb{E}_{\hat{\seq{y}} \sim \funp{p}(\hat{\seq{y}} | \seq{x})}\sum_{j=1}^J\sum_{a \in A}\funp{p}(a|\hat{{y}}_{1 \ldots j},\seq{x})\funp{Q}(a;\hat{{y}}_{1 \ldots j},\seq{y})
\label{eq:13-17}
\end{eqnarray}

\noindent 其中，$A$表示所有可能的行动组成的空间，也就是词表$V$。公式\eqref{eq:13-17}的含义是，最优策略$\hat{p}$的选择需要同时考虑当前决策的“信心”（即$\funp{p}(a|\hat{{y}}_{1 \ldots j},\seq{x})$）和未来可以获得的“价值”（即$\funp{Q}(a;\hat{{y}}_{1 \ldots j},\seq{y})$）。

\parinterval 计算动作价值函数$\funp{Q}$需要枚举$j$时刻以后所有可能的序列，而可能的序列数目是随着其长度呈指数级增长，因此只能采用估计的方法计算$\funp{Q}$的值。基于策略的强化学习方法，如最小风险训练（风险$\vartriangle=-\funp{Q}$）等都使用了采样的方法来估计$\funp{Q}$。尽管采样估计的结果是$\funp{Q}$的无偏估计，但是它的缺点在于估计的方差比较大。而$\funp{Q}$直接关系到梯度更新的大小，不稳定的数值会导致模型更新不稳定，难以优化。

\parinterval 为了避免采样的开销和随机性带来的不稳定，基于{\small\bfnew{演员-评论家}}\index{演员-评论家}（Actor-critic\index{Actor-critic}）的强化学习方法引入一个可学习的函数$\tilde{\funp{Q}}$，通过函数$\tilde{\funp{Q}}$来逼近动作价值函数$\funp{Q}$\upcite{DBLP:conf/iclr/BahdanauBXGLPCB17}。但是由于$\tilde{\funp{Q}}$是人工设计的一个函数，该函数有着自身的偏置，因此$\tilde{\funp{Q}}$不是$\funp{Q}$的一个无偏估计，所以使用$\tilde{\funp{Q}}$来指导$\funp{p}$的优化无法到达理论上的最优解。尽管如此，得益于神经网络强大的拟合能力，基于演员-评论家的强化学习方法在实践中仍然非常流行。

\parinterval 在基于演员-评论家的强化学习方法中，演员就是策略$\funp{p}$，而评论家就是动作价值函数$\funp{Q}$的估计$\tilde{\funp{Q}}$。对于演员，它的目标是找到最优的决策：
\begin{eqnarray}
\hat{p} & = & \argmax_{\funp{p}}\mathbb{E}_{\hat{\seq{y}} \sim \funp{p}(\hat{\seq{y}} | \seq{x})}\sum_{j=1}^J\sum_{a \in A}\funp{p}(a|\hat{{y}}_{1 \ldots j},\seq{x})\tilde{\funp{Q}}(a;\hat{{y}}_{1 \ldots j},\seq{y})
\label{eq:13-18}
\end{eqnarray}

\parinterval 与公式\eqref{eq:13-17}对比可以发现，基于演员-评论家的强化学习方法与基于策略的强化学习方法类似，公式\eqref{eq:13-18}对动作价值函数$\funp{Q}$的估计变成了一个可学习的函数$\tilde{\funp{Q}}$。对于目标函数里期望的计算，通常使用采样的方式来进行逼近，这与最小风险训练也是十分类似的，例如，选择一定量的$\hat{y}$来计算期望，而不是遍历所有的$\hat{y}$。借助与最小风险训练类似的方法，可以计算对$\funp{p}$的梯度来优化演员。

\parinterval 而对于评论家，它的优化目标并不是那么显而易见。尽管可以通过采样的方式来估计$\funp{Q}$，然后使用该估计作为目标让$\tilde{\funp{Q}}$进行拟合，但是这样会导致非常高的（采样）代价。同时可以想象，既然有了一个无偏估计，为什么还要用有偏估计$\tilde{\funp{Q}}$呢？

\parinterval 回顾动作价值函数的定义，可以对它做适当的展开，可以得到如下等式：
\begin{eqnarray}
\funp{Q}(\hat{{y}}_j;\hat{{y}}_{1 \ldots j -1},\seq{y}) & = & \funp{r}_j(\hat{{y}}_j;\hat{{y}}_{1 \ldots j-1},\seq{y}) + \nonumber \\
&   & \sum_{a \in A}\funp{p}(a|\hat{{y}}_{1 \ldots j},\seq{x})\funp{Q}(a;\hat{{y}}_{1 \ldots j},\seq{y})
\label{eq:13-19}
\end{eqnarray}

\parinterval 这个等式也被称为{\small\bfnew{贝尔曼方程}}\index{贝尔曼方程}（Bellman Equation\index{Bellman Equation}）\upcite{sutton2018reinforcement}。它表达了$j-1$时刻的动作价值函数$\funp{Q}(\hat{{y}}_j;\hat{{y}}_{1 \ldots j-1},\seq{y})$跟下一时刻$j$的动作价值函数$\funp{Q}(a;\hat{{y}}_{1 \ldots j},\seq{y})$之间的关系。在理想情况下，动作价值函数$\funp{Q}$应该满足上述等式，因此可以使用该等式作为可学习的函数$\tilde{\funp{Q}}$的目标。于是，可以定义$j$时刻动作价值函数为：
\begin{eqnarray}
\funp{q}_j & = &  \funp{r}_j(\hat{{y}}_j;\hat{{y}}_{1 \ldots j-1},\seq{y}) + \sum_{a \in A}\funp{p}(a|\hat{{y}}_{1 \ldots j},\seq{x})\tilde{\funp{Q}}(a;\hat{{y}}_{1 \ldots j},\seq{y})
\label{eq:13-20}
\end{eqnarray}

\noindent 相应的，评论家对应的目标定义如下：
\begin{eqnarray}
\hat{\tilde{\funp{Q}}} & = & \argmin_{\tilde{\funp{Q}}}\sum_{j=1}^J{(\tilde{\funp{Q}}(\hat{{y}}_j;\hat{{y}}_{1 \ldots j-1},\seq{y}) - \funp{q}_j)}^2
\label{eq:13-21}
\end{eqnarray}

\parinterval 此时，公式\ref{eq:13-20}与公式\ref{eq:13-21}共同组成了评论家的学习目标，使得可学习的函数$\tilde{\funp{Q}}$逼近理想的$\funp{Q}$。最后，通过同时优化演员和评论家直到收敛，获得的演员（也就是策略$\funp{p}$）就是我们期望的翻译模型。图\ref{fig:13-11}展示了演员和评论家的关系。

%----------------------------------------------
\begin{figure}[htp]
\centering
\input{./Chapter13/Figures/figure-reinforcement-learning-method-based-on-actor-critic}
\caption{基于演员-评论家的强化学习方法}
\label{fig:13-11}
\end{figure}
%----------------------------------------------

\parinterval 使用基于演员-评论家的强化学习方法还有许多细节，包括但不限于以下技巧：

\begin{itemize}
\vspace{0.5em}
\item {\small\bfnew{多目标学习}}。演员的优化通常会引入额外的极大似然估计目标函数，同时会使用极大似然估计进行预训练。这样会简化训练，因为随机初始化的演员性能很差，很难获得有效的奖励。同时极大似然估计也可以被当作一种先验知识，通过正则项的形式约束机器翻译模型的学习，防止模型陷入很差的局部最优，并加速模型收敛。
\vspace{0.5em}
\item {\small\bfnew{优化目标}}。评论家的优化目标是由自身输出所构造的。当模型更新比较快的时候模型的输出变化也会很快，导致构造的优化目标不稳定，影响模型收敛效果。一个解决方案是，在一定更新次数内固定构造优化目标使用的模型，然后再使用比较新的模型来构造后续一定更新次数内的优化目标，如此往复\upcite{DBLP:journals/nature/SilverHMGSDSAPL16}。
\vspace{0.5em}
\item {\small\bfnew{方差惩罚}}。在机器翻译中使用强化学习方法的一个问题是动作空间过大，这是由词表过大造成的。因为模型只根据被采样到的结果来进行更新，很多动作很难得到更新，因此对不同动作的动作价值函数估计值会有很大差异。此时，通常会引入一个正则项$C_j = \sum_{a \in A}{(\tilde{\funp{Q}}(a;\hat{{y}}_{1 \ldots j-1},\seq{y}) - \frac{1}{|A|} \sum_{b \in A}\tilde{\funp{Q}}(b;\hat{{y}}_{1 \ldots j-1},\seq{y}))}^2$来约束不同动作的动作函数估计值，使其不会偏离均值太远\upcite{DBLP:conf/icml/ZarembaMJF16}。
\vspace{0.5em}
\item {\small\bfnew{函数塑形}}。在机器翻译里面使用强化学习方法的另一个问题就是奖励的稀疏性。评价指标如BLEU等只能对完整的句子进行打分，也就是奖励只有在句子结尾有值，而在句子中间为0。这种情况意味着模型在生成句子的过程中没有任何信号来指导它的行为，从而大大增加了学习难度。常见的解决方案是进行{\small\bfnew{函数塑形}}\index{函数塑形}（Reward Shaping\index{Reward Shaping}），使得奖励在生成句子的过程中变得稠密，同时也不会改变模型的最优解\upcite{DBLP:conf/icml/NgHR99}。
\vspace{0.5em}
\end{itemize}

%----------------------------------------------------------------------------------------
%    NEW SECTION
%----------------------------------------------------------------------------------------

\sectionnewpage
\section{知识蒸馏}\label{subsection-7.5.3}

\parinterval 理想的机器翻译系统应该是品质好、速度快、存储占用少。不过，为了追求更好的翻译品质，往往需要更大的模型，但是相应的翻译速度会降低，模型的体积会变大。在很多场景下，这样的模型无法直接使用。比如，Transformer-Big等“大”模型通常在专用GPU服务器上运行，在手机等受限环境下仍很难应用。

\parinterval 另一方面，直接训练“小”模型的效果往往并不理想，其翻译品质与“大”模型相比仍有比较明显的差距。既然直接训练小模型无法达到很好的效果，一种有趣的想法是把“大”模型的知识传递给“小”模型。这类似于，教小孩子学习数学，是请一个权威数学家（数据中的标准答案）进行教学，而是会请一个小学数
学教师（“大”模型）来教小孩子。这就是知识蒸馏的基本思想。

%----------------------------------------------------------------------------------------
%    NEW SUB-SECTION
%----------------------------------------------------------------------------------------

\subsection{什么是知识蒸馏}

\parinterval 通常，知识蒸馏可以被看作是一种知识迁移的手段\upcite{Hinton2015Distilling}。如果把“大”模型的知识迁移到“小”模型，这种方法的直接结果就是{\small\bfnew{模型压缩}}\index{模型压缩}（Model Compression）\index{Model Compression}。当然，理论上也可以把“小”模型的知识迁移到“大”模型，比如，将迁移后得到的“大”模型作为初始状态，之后继续训练该模型，以期望取得加速收敛的效果。不过，在实践中更多是使用“大”模型到“小”模型的迁移，这也是本节讨论的重点。

\parinterval 知识蒸馏基于两个假设：

\begin{itemize}
\vspace{0.5em}
\item “知识”在模型间是可迁移的。也就是说，一个模型中蕴含的规律可以被另一个模型使用。最典型的例子就是预训练语言模型（见{\chapternine}）。使用单语数据学习到的表示模型，在双语的翻译任务中仍然可以发挥很好的作用。也就是，把单语语言模型学习到的知识迁移到双语翻译中对句子表示的任务中。
\vspace{0.5em}
\item 模型所蕴含的“知识”比原始数据中的“知识”更容易被学习到。比如，机器翻译中大量使用的回译（伪数据）方法，就把模型的输出作为数据让系统进行学习。
\vspace{0.5em}
\end{itemize}

\parinterval 这里所说的第二个假设对应了机器学习中的一大类问题\ \dash \ {\small\bfnew{学习难度}}\index{学习难度}（Learning Difficulty）\index{Learning Difficulty}。所谓难度是指：在给定一个模型的情况下，需要花费多少代价对目标任务进行学习。如果目标任务很简单，同时模型与任务很匹配，那学习难度就会降低。如果目标任务很复杂，同时模型与其匹配程度很低，那学习难度就会很大。在自然语言处理任务中，这个问题的一种表现是：在很好的数据中学习的模型的翻译质量可能仍然很差。即使训练数据是完美的，但是模型仍然无法做到完美的学习。这可能是因为建模的不合理，导致模型无法描述目标任务中复杂的规律。在机器翻译中这个问题体现的尤为明显。比如，在机器翻译系统$n$-best结果中挑选最好的译文（称为Oracle）作为训练样本让系统重新学习，系统仍然达不到Oracle的水平。

\parinterval 知识蒸馏本身也体现了一种“自学习”的思想。即利用模型（自己）的预测来教模型（自己）。这样既保证了知识可以向更轻量的模型迁移，同时也避免了模型从原始数据中学习难度大的问题。虽然“大”模型的预测中也会有错误，但是这种预测是更符合建模的假设的，因此“小”模型反倒更容易从不完美的信息中学习到更多的知识\footnote[15]{很多时候，“大”模型和“小”模型都是基于同一种架构，因此二者对问题的假设和模型结构都是相似的。}。类似于，刚开始学习围棋的人从职业九段身上可能什么也学不到，但是向一个业余初段的选手学习可能更容易入门。另外，也有研究表明：在机器翻译中，相比于“小”模型，“大”模型更容易进行优化，也更容易找到更好的模型收敛状态\upcite{li2020train}。因此在需要一个性能优越，存储较小的模型时，也会考虑将大模型压缩得到更轻量模型\upcite{DBLP:journals/corr/abs-2002-11794}。

\parinterval 通常把“大”模型看作是传授知识的“教师”，被称作{\small\bfnew{教师模型}}\index{教师模型}（Teacher Model）\index{Teacher Model}；把“小”模型看作是接收知识的“学生”，被称作{\small\bfnew{学生模型}}\index{学生模型}（Student Model）\index{Student Model}。比如，可以把Transformer-Big看作是教师模型，把Transformer-Base看作是学生模型。

%----------------------------------------------------------------------------------------
%    NEW SUB-SECTION
%----------------------------------------------------------------------------------------

\subsection{知识蒸馏的基本方法}

\parinterval 知识蒸馏的基本思路是让学生模型尽可能去拟合教师模型\upcite{Hinton2015Distilling}，通常有两种实现方式\upcite{kim-rush-2016-sequence}：

\begin{itemize}
\vspace{0.5em}
\item {\small\bfnew{基于单词的知识蒸馏}}\index{基于单词的知识蒸馏}（Word-level Knowledge Distillation）\index{Word-level Knowledge Distillation}。该方法的目标是使得学生模型的预测（分布）尽可能逼近教师模型的预测（分布）。令$\seq{x}=\{x_1,\ldots,x_m\}$和$\seq{y}=\{y_1,\ldots,y_n\}$分别表示输入和输出（数据中的答案）序列，$V$表示目标语言词表，则基于单词的知识蒸馏的损失函数被定义为：
\begin{eqnarray}
L_{\textrm{word}} = - \sum_{j=1}^n \sum_{y_j \in V} \textrm{P}_{\textrm{t}} (y_{\textrm{j}}|\seq{x})\textrm{logP}_{\textrm{s}}(y_j|\seq{x})
\label{eq:13-22}
\end{eqnarray}

这里， $\textrm{P}_{\textrm{s}}(y_j|\seq{x})$和$\textrm{P}_{\textrm{t}} (y_j|\seq{x})$分别表示学生模型和教师模型在$j$位置输出的概率。公式\eqref{eq:13-22}实际上在最小化教师模型和学生模型输出分布之间的交叉熵。
\vspace{0.5em}
\item {\small\bfnew{基于序列的知识蒸馏}}\index{基于序列的知识蒸馏}（Sequence-level Knowledge Distillation）\index{Sequence-level Knowledge Distillation}。除了单词一级输出的拟合，基于序列的知识蒸馏希望在序列整体上进行拟合。其损失函数被定义为：
\begin{eqnarray}
L_{\textrm{seq}} = - \sum_{\seq{y}}\textrm{P}_{\textrm{t}} (\seq{y}|\seq{x})\textrm{logP}_{\textrm{s}}(\seq{y}|\seq{x})
\label{eq:13-23}
\end{eqnarray}

公式\eqref{eq:13-23}要求遍历所有可能的译文序列，并进行求和。当词表大小为$V$，序列长度为$n$时，则序列的数量有$V^n$个。因此，会考虑用教师模型的真实输出序列$\hat{\seq{y}}$来代替整个空间，即假设$\textrm{P}_{\textrm{t}}(\hat{\seq{y}}|\seq{x})=1$。于是，目标函数变为：
\begin{eqnarray}
L_{\textrm{seq}} = - \textrm{logP}_{\textrm{s}}(\hat{\seq{y}} | \seq{x})
\label{eq:13-24}
\end{eqnarray}

这样的损失函数最直接的好处是，知识蒸馏的流程会非常简单。因为只需要利用教师模型将训练数据（源语言）翻译一遍，之后把它的输出替换为训练数据的目标语言部分。之后，利用新得到的双语数据训练学生模型即可。图\ref{fig:13-12}对比了词级和序列级知识蒸馏方法。
\vspace{0.5em}
\end{itemize}

%----------------------------------------------
\begin{figure}[htp]
\centering
\input{./Chapter13/Figures/figure-difference-between-word-level-and-sequence-level-in-knowledge-distillation}
\caption{词级和序列级知识蒸馏的差异}
\label{fig:13-12}
\end{figure}
%-------------------------------------------

\parinterval 本质上，基于单词的知识蒸馏与语言建模等问题的建模方式是一致的。在传统方法中，训练数据中的答案会被看作是一个One-hot分布，之后让模型去尽可能拟合这种分布。而这里，答案不再是一个One-hot分布，而是由教师模型生成的真实分布，但是损失函数的形式是一模一样的。在具体实现时，一个容易出现的问题是在词级别的知识蒸馏中，教师模型的Softmax可能会生成非常尖锐的分布。这时需要考虑对分布进行平滑，提高模型的泛化能力，比如，可以在Softmax函数中加入一个参数$\alpha$，如$\textrm{Softmax}(s_i)=\frac{\exp(s_i/\alpha)}{\sum_{i'} \exp(s_{i'}/\alpha)}$。这样可以通过$\alpha$ 控制分布的平滑程度。

\parinterval 除了在模型最后输出的分布上进行知识蒸馏，同样可以使用教师模型对学生模型的中间层输出和注意力分布进行约束。这种方法在{\chapterfourteen}中会有具体应用。

%----------------------------------------------------------------------------------------
%    NEW SUB-SECTION
%----------------------------------------------------------------------------------------

\subsection{机器翻译中的知识蒸馏}

\parinterval 在神经机器翻译中，通常使用公式\eqref{eq:13-24}的方法进行知识蒸馏，即通过教师模型构造伪数据，之后让学生模型从伪数据中学习。这样做的好处在于，系统研发人员不需要对系统进行任何修改，整个过程只需要调用教师模型和学生模型标准的训练和推断模块即可。

\parinterval 另一个问题是如何构造教师模型和学生模型。以Transformer为例，通常有两种思路：

\begin{itemize}
\vspace{0.5em}
\item 固定教师模型，通过减少模型容量的方式设计学生模型。比如，可以使用容量较大的模型作为教师模型（如：Transformer-Big或Transformer-Deep），然后通过将神经网络变“窄”、变“浅”的方式得到学生模型。例如，可以用Transformer-Big做教师模型，然后把Transformer-Big的解码器变为一层网络，作为学生模型。
\vspace{0.5em}
\item 固定学生模型，通过模型集成的方式设计教师模型。可以组合多个模型生成更高质量的译文。比如，融合多个Transformer-Big模型（不同参数初始化方式），之后学习一个Transformer-Base模型。
\vspace{0.5em}
\end{itemize}

\parinterval 此外还可以采用迭代式知识蒸馏的方式。首先，通过模型集成得到较强的教师模型，再将知识迁移到不同的学生模型上，随后继续使用这些学生模型集成新的教师模型。不断的重复上述过程可以逐步提升集成模型的性能，如图\ref{fig:13-13}所示。值得注意的是，随着迭代次数的增加，集成所带来的收益也会随着子模型之间差异性的减小而减少。

%----------------------------------------------
\begin{figure}[htp]
\centering
\input{./Chapter13/Figures/figure-ensemble-knowledge-distillation}
\caption{迭代式知识蒸馏}
\label{fig:13-13}
\end{figure}
%-------------------------------------------

\parinterval 如果倾向于使用更少的存储，更快的推理速度，则可以使用更小的学生模型。值得注意的是，对于Transformer模型来说，减少解码端的层数会给推理速度带来巨大的提升。特别是对于基于深层编码器的Transformer-Deep，适当减少解码端层数往往不会带来翻译品质的下降。可以根据不同任务的需求，选择适当大小的学生模型，来平衡存储空间、推断速度和模型品质之间的关系。

%----------------------------------------------------------------------------------------
%    NEW SECTION
%----------------------------------------------------------------------------------------

\sectionnewpage
\section{基于样本价值的学习}

\parinterval 当人在学习知识时，通常会遵循序渐进、由易到难的原则，这是一种很自然的学习策略。但是，当训练机器翻译模型时，通常是将全部的样本以随机的方式输入模型中进行学习，换句话说，就是让模型来平等地对待所有的训练样本。这种方式忽略了样本对于模型训练的“价值”，显然，更加理想的方式是优先使用价值高的样本对模型进行训练。围绕训练样本的价值差异产生了诸如数据选择、主动学习、课程学习等一系列的样本使用方法，这些学习策略本质上是在不同任务、不同背景、不同假设下，对如何高效地利用训练样本这一问题进行求解，本节即对这些技术进行介绍。

%----------------------------------------------------------------------------------------
%    NEW SUB-SECTION
%----------------------------------------------------------------------------------------

\subsection{数据选择}

\parinterval 模型学习的目的就是要学习训练数据中的分布，以期望模型学到的分布和真实的分布越接近越好。然而训练数据是从真实世界中采样得来的，这导致了训练数据无法完整地描述客观世界的真实规律。这种分布的不匹配有许多不同的表现形式，例如，类别不平衡、领域差异、存在标签噪声等，这导致模型在实践中表现不佳。

\parinterval 类别不平衡在分类任务中更为常见，可以通过重采样、代价敏感训练等手段来解决。数据选择则是缓解领域差异和标签噪声等问题的一种有效手段，它的学习策略是让模型有选择地使用样本进行学习。此外，在一些稀缺资源场景下还会面临标注数据稀少的情况，此时可以利用主动学习选择那些最有价值的样本优先进行人工标注，从而降低标注成本。

\parinterval 显然，上述方法都基于一个假设：在训练过程中，每个样本都是有价值的，且这种价值可以计算。价值在不同任务背景下有不同的含义，这与任务的特性有关。比如，在领域相关数据选择中，样本的价值表示这个样本与领域的相关性；在数据降噪中，价值表示样本的可信度；在主动学习中，价值表示样本的难易程度。

%----------------------------------------------------------------------------------------
%    NEW SUBSUB-SECTION
%----------------------------------------------------------------------------------------

\subsubsection{1. 领域相关的数据选择}

\parinterval 当机器翻译系统应用于不同领域时，训练语料与所应用领域的相关性就显得非常重要\upcite{DBLP:journals/mt/EetemadiLTR15,britz2017effective}。不同领域往往具有自己独特的属性，比如语言风格、句子结构、专业术语等，例如，“bank”这个英语单词，在金融领域通常被翻译为“银行”，而在计算机领域，一般被解释为“库”、“存储体”等。这也会导致，使用通用领域数据训练出来的模型在特定领域上的翻译效果往往不理想，这本质上是训练数据和测试数据的领域属性不匹配造成的。

\parinterval 一种解决办法是只使用特定领域的数据进行模型训练，然而这种数据往往比较稀缺。那能不能利用通用领域数据来帮助数据稀少的领域呢？这个研究方向被称为机器翻译的{\small\bfnew{领域适应}}\index{领域适应}（Domain Adaptation\index{Domain Adaptation}），即从资源丰富的领域（称为{\small\bfnew{源领域}}\index{源领域}， Source Domain\index{Source Domain}）向资源稀缺的领域（称为{\small\bfnew{目标领域}}\index{目标领域}，Target Domain\index{Target Domain}）迁移。这本身也对应着资源稀缺场景下的机器翻译问题，这类问题会在{\chaptersixteen}进行详细讨论。本章更加关注如何有效地利用训练样本以更好地适应目标领域。具体来说，可以使用{\small\bfnew{数据选择}}\index{数据选择}（Data Selection\index{Selection}）从源领域训练数据中选择与目标领域更加相关的样本进行模型训练。这样做的一个好处是，源领域中混有大量与目标领域不相关的样本，数据选择可以有效降低这部分数据的比例，这样可以更加突出与领域相关样本的作用。

\parinterval 数据选择所要解决的核心问题是：给定一个目标领域/任务数据集（如，目标任务的开发集），如何衡量原始训练样本与目标领域/任务的相关性？主要方法可以分为以下几类：

\begin{itemize}
\vspace{0.5em}
\item {\small\bfnew{基于交叉熵差}}\index{交叉熵差}（Cross-entropy Difference\index{Cross-entropy Difference}，CED）{\small\bfnew{的方法}}\upcite{DBLP:conf/emnlp/AxelrodHG11,DBLP:conf/wmt/AxelrodRHO15,DBLP:conf/emnlp/WangULCS17,DBLP:conf/iwslt/MansourWN11}。该方法在目标领域数据和通用数据上分别训练语言模型，然后用两个语言模型来给句子打分并做差，差越小说明句子与目标领域越相关。
\vspace{0.5em}
\item {\small\bfnew{基于文本分类的方法}}\upcite{DBLP:conf/conll/ChenH16,chen2016bilingual,DBLP:conf/aclnmt/ChenCFL17,DBLP:conf/wmt/DumaM17}。将问题转化为文本分类问题，先构造一个领域分类器，之后利用分类器对给定的句子进行领域分类，最后用输出的概率来打分，选择得分高的样本。
\vspace{0.5em}
\item {\small\bfnew{基于特征衰减算法}}\index{特征衰减算法}（Feature Decay Algorithms\index{Feature Decay Algorithms}，FDA）{\small\bfnew{的方法}}\upcite{DBLP:conf/wmt/BiciciY11,poncelas2018feature,DBLP:conf/acl/SotoSPW20}。该算法基于特征匹配，试图从源领域中提取出一个句子集合，这些句子能够最大程度覆盖目标领域的语言特征。
\vspace{0.5em}
\end{itemize}

\parinterval 上述方法实际上描述了一种静态的学习策略，即首先利用评分函数对源领域的数据进行打分排序，然后选取一定数量的数据合并到目标领域数据集中，并共同训练模型\upcite{DBLP:conf/emnlp/AxelrodHG11,DBLP:conf/wmt/AxelrodRHO15,chen2016bilingual,DBLP:conf/conll/ChenH16}。这个过程其实是扩大了目标领域的数据规模，模型的收益主要来自于数据的增加。但是研究人员也发现静态方法会存在两方面的缺陷：

\begin{itemize}
\vspace{0.5em}
\item 在选定的子集上进行训练会导致词表覆盖率的降低，并加剧单词长尾分布问题\upcite{DBLP:conf/wmt/AxelrodRHO15,DBLP:conf/emnlp/WeesBM17}。
\vspace{0.5em}
\item 静态方法可以看作一种数据过滤技术，它对数据的判定方式是“非黑即白”的，即接收或拒绝。这种方式一方面会受到评分函数的影响，一方面被拒绝的数据可能对于训练模型仍然有用，而且样本的价值可能会随着训练过程的推进而改变\upcite{DBLP:conf/wmt/WangWHNC18}。
\vspace{0.5em}
\end{itemize}

\parinterval 使用动态学习策略可以有效地缓解上述问题。它的基本想法是：不完全抛弃领域相关性低的样本，而只是使模型给予相关性高的样本更高的关注度，使得它更容易参与到训练过程中。具体在实现上，主要有两种方法，一种是将句子的领域相似性表达成概率分布，然后在训练过程中根据该分布对数据进行动态采样\upcite{DBLP:conf/emnlp/WeesBM17,DBLP:conf/acl/WangUS18}， 另一种是在计算损失函数时根据句子的领域相似性以加权的方式进行训练\upcite{DBLP:conf/emnlp/WangULCS17,DBLP:conf/aclnmt/ChenCFL17}。 相比于静态方法的二元选择方式，动态方法是一种“软”选择的方式，这使得模型有机会使用到其它数据，提高了训练数据的多样性，因此性能也更稳定。

%----------------------------------------------------------------------------------------
%    NEW SUBSUB-SECTION
%----------------------------------------------------------------------------------------

\subsubsection{2. 数据降噪}

\parinterval 除了领域差异，训练数据中也存在噪声，比如，机器翻译所使用的数据中经常出现句子未对齐、多种语言文字混合、单词丢失等问题。相关研究表明神经机器翻译对于噪声数据很敏感\upcite{DBLP:conf/aclnmt/KhayrallahK18}，因此无论是从训练效果还是训练效率出发，数据降噪都是很有意义的。事实上，在统计机器翻译时代，就有很多数据降噪方面的研究工作\upcite{DBLP:conf/coling/FormigaF12,DBLP:conf/acl/CuiZLLZ13,DBLP:phd/dnb/Mediani17}，因此许多方法也可以应用到神经机器翻译中来。

\parinterval 含有噪声的数据通常都具有较为明显的特征，因此可以用诸如句子长度比、词对齐率、最长连续未对齐序列长度等一些特征来对句子进行综合评分\upcite{rarrick2011mt,taghipour2011parallel,Xu2017ZipporahAF}；也可以将该问题转化为分类任务来对句子进行筛选\upcite{DBLP:conf/aclnmt/CarpuatVN17,DBLP:conf/naacl/VyasNC18}；此外，从某种意义上来说，数据降噪其实也可以算是一种领域数据选择，因为它的目标是选择可信度高的样本，因此也可以人工构建一个可信度高的小数据集，然后利用该数据集和通用数据集之间的差异性进行选择\upcite{DBLP:conf/wmt/WangWHNC18}。

\parinterval 早期的工作大多在关注过滤噪声样本，但对如何利用噪声样本探讨较少。事实上，噪声是有强度的，有些噪声样本对于模型可能是有价值的，而且它们的价值可能会随着模型的状态而改变\upcite{DBLP:conf/wmt/WangWHNC18}。对于一个双语句对“我/喜欢/那个/地方/。 $\leftrightarrow$ I love that place. It's very beautiful”。一方面来说，虽然这两个句子都很流畅，但是由于汉语句子中缺少了一部分翻译，因此简单的基于长度或双语词典的方法可以很容易将其过滤掉。从另一方面来说，这个样本对于训练机器翻译模型仍然有用，特别是在数据稀缺的情况下，因为汉语句子和英语句子的前半部分仍然是正确的互译结果。这表明了噪声数据的微妙之处，它不是对应着简单的二元分类问题：一些训练样本可能部分有用。因此简单的过滤并不一种很好的办法，一种更加理想的学习策略应该是既可以合理的利用这些数据，又不让其对模型产生负面影响。例如，在训练过程中对批量数据的噪声水平进行{\small\bfnew{退火}}\index{退火}（Anneal）\index{Anneal}，使得模型在越来越干净的数据上进行训练\upcite{DBLP:conf/wmt/WangWHNC18,DBLP:conf/acl/WangCC19}。从宏观上看，整个训练过程其实是一个持续微调的过程，这和微调的思想基本一致。这种学习策略一方面充分利用了训练数据，一方面又避免了噪声数据对模型的负面影响，因此取得了不错的效果。

%----------------------------------------------------------------------------------------
%    NEW SUBSUB-SECTION
%----------------------------------------------------------------------------------------

\subsubsection{3. 主动学习}

\parinterval {\small\bfnew{主动学习}}\index{主动学习}（Active Learning\index{Active Learning}）也是一种数据选择策略。它最初的应用场景是：标注大量的数据成本过高，因此希望优先标注对模型最有价值的数据，这样可以最大化模型学习的效率，同时降低数据标注的整体代价\upcite{DBLP:conf/coling/ZhuWH08}。主动学习主要由五个部分组成，包括：未标注样本池、筛选策略、标注者、标注样本集、目标模型。在主动学习过程中，会根据当前的模型状态找到未标注样本池中最有价值的样本，之后送给标注者。标注结束后，会把标注的样本加入到标注样本集中，之后用这些标注的样本更新模型。之后，重复这个过程，直到到达某种收敛状态。

\parinterval 主动学习的一个核心问题是：如何选择出那些最有价值的未标注样本？通常会假设模型认为最“难”的样本是最有价值的。具体实现有很多思路，例如，基于置信度的方法、基于分类错误的方法等等\upcite{DBLP:journals/tslp/ZhuM12,DBLP:conf/coling/ZhuWYT08}。

\parinterval 在机器翻译中，主动学习可以被用于低资源翻译，以减少人工标注的成本\upcite{DBLP:conf/conll/LiuBH18,DBLP:conf/emnlp/ZhaoZZZ20}。也可以被用于交互式翻译，让模型持续从外界反馈中受益\upcite{Peris2018ActiveLF,DBLP:journals/pbml/TurchiNFF17,DBLP:journals/csl/PerisC19}。不过，总的来说，主动学习在机器翻译中应用不算广泛。这是由于，机器翻译任务很复杂，设计样本价值的评价函数较为困难。而且，在很多场景中，并不是要简单的选择样本，而是希望训练装置能够考虑样本的价值，以充分发挥所有数据的优势。这也正是即将介绍的课程学习等方法要解决的问题。

%----------------------------------------------------------------------------------------
%    NEW SUB-SECTION
%----------------------------------------------------------------------------------------

\subsection{课程学习}
\label{sec:curriculum-learning}

\parinterval {\small\bfnew{课程学习}}\index{课程学习}（Curriculum Learning）\index{Curriculum Learning}的基本思想是：先学习简单的、普适性的知识，然后逐渐增加难度，学习更复杂、更专业化的知识。在统计模型训练中，这种思想可以体现在让模型按照由“易”到“难”的顺序对样本进行学习\upcite{DBLP:conf/icml/BengioLCW09}，这本质上是一种样本使用策略。以神经机器翻译使用的随机梯度下降为例，在传统的方法中，所有训练样本都是随机呈现给模型的，换句话说，就是让模型平等地对待所有的训练样本，这忽略了数据样本的各种复杂性和当前模型的学习状态。所以模拟人类由易到难的学习过程就是一种很自然的想法，这样做的好处在于：

\begin{itemize}
\vspace{0.5em}
\item {\small\bfnew{加速模型训练}}。在达到相同的性能条件下，课程学习可以加速训练，减少训练迭代步数。
\vspace{0.5em}
\item {\small\bfnew{使模型获得更好的泛化性能}}。即通过对简单样本的学习，让模型不至于过早进入拟合复杂样本的状态。
\vspace{0.5em}
\end{itemize}

\parinterval 课程学习是符合直觉的，可以想象，对于一个数学零基础的人来说，如果一开始就同时学习加减乘除和高等数学，效率自然是比较低下的。而如果按照正常的学习顺序，比如先学习加减乘除，然后学习各种函数，最后再学习高等数学，有了前面的基础，再学习后面的知识，效率就可以更高。事实上，课程学习自从被提出就受到了研究人员的极大关注，除了想法本身有趣之外，还因为它作为一种和模型无关的训练策略，具有即插即用的特点。神经机器翻译就是一种很契合课程学习的任务，这是因为神经机器翻译往往需要大规模的平行语料来训练模型，训练成本很高，所以使用课程学习来加快收敛是一个很自然的想法。

\parinterval 那么如何设计课程学习方法呢？有两个核心问题：

\begin{itemize}
\vspace{0.5em}
\item {\small\bfnew{如何评估每个样本的难度}}？即设计评估样本学习难易度的准则，简称{\small\bfnew{难度评估准则}}\index{难度评估准则}（Difficulty Criteria\index{Difficulty Criteria}）
\vspace{0.5em}
\item {\small\bfnew{以何种策略来规划训练数据}}？即何时为训练提供更复杂的样本，以及提供多少样本等，称为{\small\bfnew{课程规划}}\index{课程规划}（Curriculum Schedule\index{Curriculum Schedule}）
\vspace{0.5em}
\end{itemize}

\parinterval 这里，把这两个问题抽象成两个模块：难度评估器和训练调度器，那么课程学习的一个大致的流程如图\ref{fig:13-14}所示。首先，难度评估器对训练样本按照由易到难的顺序进行排序，最开始调度器从相对容易的数据块中采样训练样本，发送给模型进行训练，随着训练时间的推移，训练调度器将逐渐从更加困难的数据块中进行采样（至于何时，以及选择何种采样方式则取决于设定的策略），持续这个过程，直到从整个训练集进行均匀采样。

%----------------------------------------------
\begin{figure}[htp]
\centering
\input{./Chapter13/Figures/figure-curriculum-learning-framework}
\caption{课程学习框架}
\label{fig:13-14}
\end{figure}
%-------------------------------------------

\parinterval 评估样本的难度和具体的任务相关，在神经机器翻译中，有很多种评估方法，可以利用语言学上的困难准则，比如句子长度、句子平均词频、句法树深度等\upcite{DBLP:conf/naacl/PlataniosSNPM19,DBLP:conf/ranlp/KocmiB17}。这些准则本质上属于人类的先验知识，符合人类的直觉，但不一定和模型相匹配。对人类来说简单的句子对模型来说可能并不简单，所以研究人员也提出了基于模型的方法，比如：语言模型\upcite{DBLP:conf/acl/WangCC19,DBLP:conf/naacl/ZhangSKMCD19}，或者神经机器翻译模型\upcite{zhang2018empirical,DBLP:conf/coling/XuHJFWHJXZ20}都可以用于评价样本的难度。值得注意的是，利用神经机器翻译来打分的方法分为静态和动态两种。静态的方法是利用在小数据集上训练的、更小的翻译模型来打分\upcite{zhang2018empirical}。动态的方法则是利用当前模型的状态来打分，这在广义上也叫作{\small\bfnew{自步学习}}\index{自步学习}（Self-paced Learning\index{Self-paced Learning}），通常可以利用模型的训练误差或变化率等指标进行样本难度的估计\upcite{DBLP:conf/coling/XuHJFWHJXZ20}。

\parinterval 虽然样本难度的度量在不同任务中有所不同，但课程规划通常与数据和任务无关。在各种场景中，大多数课程学习都利用了类似的调度策略。具体而言，调度策略可以分为预定义的和自动的两种。预定义的调度策略通常将按照难易程度排序好的样本划分为块，每个块中包含一定数量的难度相似的样本。然后按照“先易后难”的原则人工定义一个调度策略，比如，一种较为流行的方法是：在训练早期，模型只在简单块中进行采样，随着训练过程的进行，将下一个块的样本合并到当前训练子集中，继续训练，直到合并了整个数据块，即整个训练集可见为止，之后再继续训练直到收敛。这个过程如图\ref{fig:13-15}所示。类似的还有一些其他变体，比如，训练到模型可见整个数据集之后，将最难的样本块复制并添加到训练集中，或者是将最容易的数据块逐渐删除，然后再添加回来等，这些方法的基本想法都是想让模型在具备一定的能力之后更多关注于困难样本。

%----------------------------------------------
\begin{figure}[htp]
\centering
\input{./Chapter13/Figures/figure-a-predefined-course-planning}
\caption{“先易后难”数据块选择}
\label{fig:13-15}
\end{figure}
%-------------------------------------------

\parinterval 尽管预定义的调度策略简单有效，但也会面临着方法不够灵活、数据块划分不合理等问题，而且这种策略在一定程度上也忽略了当前模型的反馈。因此另一种方法是自动的方法，根据模型的反馈来动态调整样本的难度或调度策略，模型的反馈可以是模型的不确定性\upcite{DBLP:conf/acl/ZhouYWWC20}、模型的能力\upcite{DBLP:conf/naacl/PlataniosSNPM19,DBLP:conf/coling/XuHJFWHJXZ20}等。这些方法在一定程度上使得整个训练过程和模型的状态相匹配，同时样本的选择过渡得更加平滑，因此在实践中取得了不错的效果。

%----------------------------------------------------------------------------------------
%    NEW SUB-SECTION
%----------------------------------------------------------------------------------------

\subsection{持续学习}

\parinterval 人类具有不断学习、调整和转移知识的能力，这种能力被称为{\small\bfnew{持续学习}}\index{持续学习}（Continual Learning\index{Continual Learning}），也叫{\small\bfnew{终生学习}}（Lifelong Learning\index{Lifelong Learning}）或{\small\bfnew{增量式学习}}\index{增量式学习}（Incremental Learning\index{Incremental Learning}）。人类学习的新任务时，会很自然的利用以前的知识并将新学习的知识整合到以前的知识中。然而对于机器学习系统来说，尤其在连接主义的范式下（如深度神经网络模型），这是一个很大的挑战，这是由神经网络的特性所决定的。当前的神经网络模型依赖于标注的训练样本，通过反向传播算法对模型参数进行训练更新，最终达到拟合数据分布的目的。当把模型切换到新的任务时，本质上是数据的分布发生了变化，从这种分布差异过大的数据中不断增量获取可用信息很容易导致{\small\bfnew{灾难性遗忘}}\index{灾难性遗忘}（Catastrophic Forgetting\index{Catastrophic Forgetting}）问题，即用新数据训练模型的时候会干扰先前学习的知识。甚至，这在最坏的情况下会导致旧知识被新知识完全重写。在机器翻译领域，类似的问题经常发生在不断增加数据的场景中，因为当用户使用少量数据对模型进行更新之后，发现在旧数据上的性能下降了（见{\chaptereighteen}）。

\parinterval 为克服灾难性遗忘问题，学习系统一方面必须能连续获取新知识和完善现有知识，另一方面，还应防止新数据输入明显干扰现有的知识，这个问题称作{\small\bfnew{稳定性-可塑性}}\index{稳定性- 可塑性}（Stability-Plasticity\index{Stability-Plasticity}）问题。可塑性指整合新知识的能力，稳定性指保留先前的知识不至于遗忘。要解决这些问题，就需要模型在保留先前任务的知识与学习当前任务的新知识之间取得平衡。目前的解决方法可以分为以下几类：

\begin{itemize}
\vspace{0.5em}
\item {\small\bfnew{基于正则化的方法}}。通过对模型参数的更新施加约束来减轻灾难性的遗忘，通常是在损失函数中引入了一个额外的正则化项，使得模型在学习新数据时巩固先前的知识\upcite{DBLP:journals/pami/LiH18a,DBLP:conf/iccv/TrikiABT17}。
\vspace{0.5em}
\item {\small\bfnew{基于实例的方法}}。基于实例的方法。在学习新任务的同时混合训练先前的任务样本以减轻遗忘，这些样本可以是从先前任务的训练数据中精心挑选出的子集，或者利用生成模型生成的伪样本\upcite{DBLP:conf/cvpr/RebuffiKSL17,DBLP:conf/eccv/CastroMGSA18}。
\vspace{0.5em}
\item {\small\bfnew{基于动态模型架构的方法}}。例如，增加神经元或新的神经网络层进行重新训练，或者是在新任务训练时只更新部分参数\upcite{rusu2016progressive,DBLP:journals/corr/FernandoBBZHRPW17}。
\vspace{0.5em}
\end{itemize}

\parinterval 从某种程度上看，多领域、多语言机器翻译等都可以被看做是广义上的持续学习。在多领域神经机器翻译中，研究人员期望一个在通用数据上学习的模型可以继续在新的领域有良好的表现。在多语言神经机器翻译中，研究人员期望一个模型可以支持更多语种的翻译，甚至当新的语言到来时不需要修改模型结构。以上这些问题在{\chaptersixteen}和{\chaptereighteen}中还会有详细讨论。

%----------------------------------------------------------------------------------------
%    NEW SECTION
%----------------------------------------------------------------------------------------

\sectionnewpage
\section{小结及拓展阅读}

\parinterval 本章以不同的角度讨论了神经机器翻译模型的训练问题。一方面，可以作为{\chapternine}$\sim${\chaptertwelve}内容的扩展，另一方面，也为本书后续章节的内容进行铺垫。从机器学习的角度看，本章介绍的很多内容并不仅仅使用在机器翻译中，大多数的内容同样适用于其它自然语言处理任务。此外，本章也讨论了许多与机器翻译相关的问题（如大词表），这又使得本章的内容具有机器翻译的特性。总的来说，模型训练是一个非常开放的问题，在后续章节中还会频繁涉及。同时，也有一些方向可以关注：

\begin{itemize}
\vspace{0.5em}
\item 对抗样本除了用于提高模型的健壮性之外，还有很多其他的应用场景，比如评估模型。通过构建由对抗样本构造的数据集，可以验证模型对于不同类型噪声的健壮性\upcite{DBLP:conf/emnlp/MichelN18}。 但是在生成对抗样本时常常要考虑很多问题，比如扰动是否足够细微\upcite{DBLP:conf/cvpr/Moosavi-Dezfooli16,DBLP:conf/cvpr/NguyenYC15}，在人类难以察觉的同时做到欺骗模型的目的；对抗样本在不同的模型结构或数据集上是否具有足够的泛化能力\upcite{DBLP:conf/iclr/LiuCLS17,DBLP:journals/tnn/YuanHZL19}；生成的方法是否足够高效等等\upcite{DBLP:conf/emnlp/JiaL17,DBLP:conf/infocom/YuanHL020}。

\vspace{0.5em}
\item 此外，在机器翻译中，强化学习的应用也有很多，比如，MIXER算法用混合策略梯度和极大似然估计的目标函数来更新模型\upcite{Ranzato2016SequenceLT}，DAgger\upcite{DBLP:journals/jmlr/RossGB11}以及DAD\upcite{DBLP:conf/aaai/VenkatramanHB15}等算法在训练过程之中逐渐让模型适应推断阶段的模式。此外，强化学习的效果目前还相当不稳定，研究人员提出了大量的方法来进行改善，比如降对动作价值函数$\funp{Q}$的估计的方差\upcite{DBLP:conf/iclr/BahdanauBXGLPCB17,DBLP:conf/emnlp/NguyenDB17}、使用单语语料\upcite{Sennrich2016ImprovingNM,DBLP:conf/emnlp/WuTQLL18}等等。

\vspace{0.5em}
\item 从广义上说，大多数课程学习方法都是遵循由易到难的原则，然而在实践过程中人们逐渐赋予了课程学习更多的内涵，课程学习的含义早已超越了最原始的定义。一方面，课程学习可以与许多任务相结合，此时，评估准则并不一定总是样本的困难度，这取决于具体的任务。或者说，我们更关心的是样本带给模型的“价值”，而非简单的难易标准。另一方面，在一些任务或数据中，由易到难并不总是有效，有时困难优先反而会取得更好的效果\upcite{DBLP:conf/medprai/SurendranathJ18,zhang2018empirical}。实际上这和人类的直觉不太符合，一种合理的解释是课程学习更适合标签噪声、离群值较多或者是目标任务困难的场景，能提高模型的健壮性和收敛速度，而困难优先的策略则更适合数据集干净的场景\upcite{DBLP:conf/nips/ChangLM17}。

\vspace{0.5em}
\end{itemize}
